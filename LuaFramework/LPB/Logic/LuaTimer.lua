---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zlc.
--- DateTime: 2020/6/8 17:45
---
--计时器类别
LuaTimer ={
    time_scale = 1;--用于暂停
    cur_time = 0 ;--当前时间
    timerTasks={};--延时任务
    timerLoopTasks={};--延时循环任务
    taskIndex = {};--任务编号
};

LuaTimer.TimerType = {
	Default 	= 1;
	UI			= 2;
	Network		= 3;
	Battle		= 4;
	Living      = 5;
	BattleUI		= 6;
	Guide       =7
}


function LuaTimer:Init()
 
    self.cur_time = 0
    self.time_scale = 1

	for i, v in pairs(self.TimerType) do
		self.taskIndex[v] = tonumber(v)*10000
		--log.r(v.."   StartIndex*10000   "..(self.taskIndex[v] ))
	end

    if(self.update_x_handler)then 
        self:_Stop()
        self:Clear()
    end

    self.update_x_handler =  UnityTick.update_tick_add(xp_call(function()
        LuaTimer:Update(Time.deltaTime)
    end))
end
function LuaTimer:SetPause(bool)
    if bool then
        self.time_scale = 0
    else
        self.time_scale = 1
    end
end

function LuaTimer:_Stop()
    if self.update_x_handler then
		UpdateBeat:RemoveListener(self.update_x_handler)
		self.update_x_handler = nil
	end
end


--设置延时循环函数 id,初次延时,循环后间隔延时,循环时间,循环函数,结束时回调函数
--[[
    @desc: 
    author:{author}
    time:2020-11-16 16:30:02
    --@delayTime:初次延时
	--@loopDelay:循环后间隔延时
	--@loopCout:循环时间  -1表示无限
	--@funcLoop:循环函数
	--@funcOnFinish: 结束时回调函数
    @return:
]]
function LuaTimer:SetDelayLoopFunction(delayTime, loopDelay, loopCout, funcLoop,funcOnFinish,is_real_time,timer_type)
    local cur_time = nil
    if is_real_time then
        cur_time = UnityEngine.Time.time
    else
        cur_time = self.cur_time
    end
	
	local timerType = self.TimerType.Default;
	if timer_type then
		timerType = timer_type;
	end
	
	if self.timerLoopTasks[timerType] == nil then
		self.timerLoopTasks[timerType] = {};
	end
	if self.timerLoopTasks[timerType][self.taskIndex[timerType]] == nil then
		self.timerLoopTasks[timerType][self.taskIndex[timerType]] = {};
	end

	self.timerLoopTasks[timerType][self.taskIndex[timerType]].startTime= cur_time+delayTime;--触发时机
	self.timerLoopTasks[timerType][self.taskIndex[timerType]].loopDelay=loopDelay;--每次循环的间隔
    if(loopCout==-1)then 
		self.timerLoopTasks[timerType][self.taskIndex[timerType]].overTime=-1;--循环持续时间  -1表示无限
	--- Logic/LuaTimer:78: attempt to perform arithmetic on local 'loopCout' (a nil value)
    elseif loopCout then
		self.timerLoopTasks[timerType][self.taskIndex[timerType]].overTime= cur_time +loopCout*loopDelay+delayTime;--循环持续时间
	else
		self.timerLoopTasks[timerType][self.taskIndex[timerType]].overTime= cur_time +1*loopDelay+delayTime;--循环持续时间
    end
  
	self.timerLoopTasks[timerType][self.taskIndex[timerType]].funcLoop=funcLoop;--循环函数
	self.timerLoopTasks[timerType][self.taskIndex[timerType]].funcOnFinish=funcOnFinish;--结束时回调函数
	self.taskIndex[timerType] = self.taskIndex[timerType] + 1;
    return self.taskIndex[timerType] - 1;
end
--延时函数 id，延时时间，触发方法
function LuaTimer: SetDelayFunction(delayTime, func,is_real_time, timer_type)
    if(delayTime==0)then 
        fun.SafeCall(func)
        return 
    end

    if(delayTime<0)then 
        log.r(" delay time <0 !")
        return 
    end
	
	local timerType = self.TimerType.Default;
	if timer_type then
		timerType = timer_type;
	end	

    if self.timerTasks[timerType] == nil then
        self.timerTasks[timerType] = {};
    end
	if self.timerTasks[timerType][self.taskIndex[timerType]] == nil then
		self.timerTasks[timerType][self.taskIndex[timerType]] = {};
	end
	
	self.timerTasks[timerType][self.taskIndex[timerType]].func = func;
	self.timerTasks[timerType][self.taskIndex[timerType]].is_real_time = is_real_time
    local startTime = nil
    if is_real_time then
        startTime = UnityEngine.Time.time+ delayTime
    else
        startTime = self.cur_time + delayTime
    end
	self.timerTasks[timerType][self.taskIndex[timerType]].startTime = startTime;
	self.taskIndex[timerType] = self.taskIndex[timerType] + 1;
	--log.r("self.taskIndex[timerType]  "..(self.taskIndex[timerType] - 1))
    return self.taskIndex[timerType] - 1;
end
--更新SetMachinePause
function LuaTimer:Update(delta_time)
    self.cur_time = self.cur_time + delta_time * self.time_scale

   self:UpdateTask()
end
function LuaTimer:UpdateTask()
    local cur_time = nil
	for i, tasks in pairs(self.timerTasks) do
		if tasks and type(tasks) == "table" then
			for k, v in pairs(tasks) do
				if(v.is_real_time) then --不受游戏逻辑性暂停影响
					cur_time = UnityEngine.Time.time
				else
					cur_time = self.cur_time
				end

				--满足延时条件 触发
				if v.startTime < cur_time then
					if v.func~=nil then
						v.func();--延时方法
					end
					self.timerTasks[i][k] = nil--回收任务
				end
			end
		end
	end
	
	for i, tasks in pairs(self.timerLoopTasks) do
		for k,v in pairs(tasks) do
			if(v.is_real_time) then --不受游戏逻辑性暂停影响
				cur_time = UnityEngine.Time.time
			else
				cur_time = self.cur_time
			end
			--过期任务
			if v.overTime ~= -1 and  v.overTime < cur_time then
				if v.funcOnFinish~=nil then
					v.funcOnFinish();--循环方法结束回调
				end
				self.timerLoopTasks[i][k]=nil;--回收任务
				--有效任务
			else
				--满足触发条件
				if v.startTime < cur_time then
					if v.funcLoop~=nil then
						v.funcLoop();--循环方法
					end
					v.startTime=v.startTime+v.loopDelay;--设置下一次触发时间
				end
			end
		end
	end
end

function LuaTimer:Complete(id,timer_type)
	local timerType = self.TimerType.Default;
	if timer_type then
		timerType = timer_type;
	end
	if self.timerTasks[timerType] and self.timerTasks[timerType][id] then
        local task = self.timerTasks[timerType][id]
        if task.func~=nil then
            task.func()
        end
        self.timerTasks[timerType][id] = nil
    end

    if self.timerLoopTasks[timerType] and self.timerLoopTasks[timerType][id] then
        local task = self.timerLoopTasks[timerType][id]
        if task.funcOnFinish~=nil then
            task.funcOnFinish();--循环方法结束回调
        end
    end
    self.timerLoopTasks[timerType][id]=nil;
end
--撤销任务
function LuaTimer:Remove(id,timer_type)
    if id == nil then
        return
    end
	local timerType = self.TimerType.Default;
	if timer_type then
		timerType = timer_type;
	else
		LuaTimer:RemoveDefault(id)
		return
	end
	if self.timerTasks[timerType] and self.timerTasks[timerType][id] then
		self.timerTasks[timerType][id] = nil;
	end	
    
    if self.timerLoopTasks[timerType] and self.timerLoopTasks[timerType][id] then 
        local task = self.timerLoopTasks[timerType][id]
        if task.funcOnFinish~=nil then
            task.funcOnFinish();--循环方法结束回调
        end
		self.timerLoopTasks[timerType][id] = nil;
    end 
end

function LuaTimer:RemoveDefault(id)
	if id == nil then
		return
	end
	local timerTypeList = {
		self.TimerType.Default,
		self.TimerType.UI,
		self.TimerType.Battle,
		self.TimerType.BattleUI,
		self.TimerType.Guide,
	}
	for i = 1, #timerTypeList do
		LuaTimer:Remove(id,timerTypeList[i])
	end
end

function LuaTimer:ClearTaskList(list,timer_type)
    if list == nil then
        return
    end
	local timerType = self.TimerType.Default;
	if timer_type then
		timerType = timer_type;
	end
    for i, v in pairs(list) do
        self:Remove(v,timerType);
    end
end

--清理
---@param timer_type number @定时器类型1默认2UI3网络4战斗5持续存在
---@param containNet boolean @是否包含网络定时器
function LuaTimer:Clear(timer_type,containNet)
    self:SetPause(false)
	if timer_type then
		if self.timerTasks[timer_type] then
			for k, v in pairs(self.timerTasks[timer_type]) do
				self.timerTasks[timer_type][k] = nil;
			end
		end
		if self.timerLoopTasks[timer_type] then
			for k, v in pairs(self.timerLoopTasks[timer_type]) do
				self.timerLoopTasks[timer_type][k] = nil;
			end
		end
		if self.taskIndex[timer_type] then
			self.taskIndex[timer_type] = 1;
		end	
	else
		local clearTypes = {};
		if containNet then
			clearTypes = self.TimerType;
		else
			for i, v in pairs(self.TimerType) do
				if v ~= self.TimerType.Network then
					clearTypes[i] = v;
				end
			end	
		end	

		for i, timerType in pairs(clearTypes) do
			if self.timerTasks[timerType] then
				for k, v in pairs(self.timerTasks[timerType]) do
					self.timerTasks[timerType][k] = nil;
				end
			end
			
			if self.timerLoopTasks[timerType] then
				for k, v in pairs(self.timerLoopTasks[timerType]) do
					self.timerLoopTasks[timerType][k] = nil;
				end
			end
			
			if self.taskIndex[timerType] then
				self.taskIndex[timerType] = 1;
			end			
		end
	end
end

--改变LoopDelay时间
function LuaTimer:ChangeLoopDelayTime(id, newLoopDelay,timer_type)
	local timerType = self.TimerType.Default;
	if timer_type then
		timerType = timer_type;
	end
	if self.timerLoopTasks[timerType] then
		for k, v in pairs(self.timerLoopTasks[timerType]) do
			if k == id then
				self.timerLoopTasks[timerType][k].loopDelay = newLoopDelay
			end
		end
	end	
end
