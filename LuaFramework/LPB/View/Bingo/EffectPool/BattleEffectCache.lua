---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2022/2/21 18:34
---

require("View/Bingo/EffectPool/GoPool")
--  缓存战斗中需要 频繁出现且数据多的特效
BattleEffectCache = Clazz(ClazzBase,"BattleEffectCache")
local this = BattleEffectCache

local skillContainer = nil
local bingoContainer = nil
local bindEffectes ={}

function BattleEffectCache:New()

end

function BattleEffectCache:CreateBattleEffect(sourceRef)
    skillContainer = sourceRef.PuEffectContainer
    bingoContainer = sourceRef.BingoEffectContainer
end

---@see  加载自由预设
function BattleEffectCache:GetFreePrefabFromCache(prefabName, parentObj,recycleTime,func)
    Cache.load_prefabs(AssetList[prefabName],prefabName,function(obj)
        local go = fun.get_instance(obj)
        fun.set_parent(go,parentObj,true)
        if func then
            func(go)
        end
        if recycleTime and recycleTime>0 then
            Destroy(go,recycleTime)
        end
    end)
end

---@see  加载自由预设2
function BattleEffectCache:GetFreePrefabFromCache2(prefabName,containerName,recycleTime,target)
    Cache.load_prefabs(AssetList[prefabName],prefabName,function(obj)
        local go = fun.get_instance(obj)
        local parentObj = BattleEffectPool:GetContainer(containerName)
        fun.set_parent(go,parentObj,true)
        if target then
            if type(target) == "table" then
                fun.set_gameobject_pos(go,target.x,target.y,target.z,false)
            else
                fun.set_same_position_with(go,target)
            end            
        end
        --func(go)
        fun.set_active(go,true)
        Destroy(go,recycleTime)
    end)
end

---@see  加载自由预设2
function BattleEffectCache:GetFreePrefabFromCache3(prefabName,containerName,recycleTime,target,func)
    Cache.load_prefabs(AssetList[prefabName],prefabName,function(obj)
        local go = fun.get_instance(obj)
        local parentObj = BattleEffectPool:GetContainer(containerName)
        fun.set_parent(go,parentObj,true)
        if target then
            if type(target) == "table" then
                fun.set_gameobject_pos(go,target.x,target.y,target.z,false)
            else
                fun.set_same_position_with(go,target)
            end
        end
        func(go)
        fun.set_active(go,true)
        Destroy(go,recycleTime)
    end)
end

--- 加载预设_挂在bingoContainer层级
---@param prefabName 预设名字
---@param targetObj 目标物体_保持和目标同步
---@param cardId 卡牌ID
---@param effectType 特效类型0普通_1bingo_2Jackpot
function BattleEffectCache:GetPrefabFromCache(prefabName,targetObj, func,cardId,effectType,addCover,parentLayer)
    Cache.load_prefabs(AssetList[prefabName],prefabName,function(obj)
        local go = fun.get_instance(obj)
        fun.set_parent(go,bingoContainer,true)
        if targetObj then
            if not cardId then  cardId = -1 else cardId = tonumber(cardId) end
            if not effectType then  effectType =0 end
            local coverObj = nil
            if addCover then
                fun.set_active(obj,false)
                coverObj = UnityEngine.GameObject.New("Cover")
                fun.set_parent(coverObj,obj.transform.parent,true)
                fun.set_same_position_with(coverObj,targetObj)
                fun.set_parent(obj,coverObj,true)
            else
                fun.set_same_position_with(go,targetObj)
            end
            table.insert(bindEffectes,{target = targetObj,go = go,cardId = cardId,isJackpot = (effectType == 2),
                                       coverObj = coverObj,isBingo = (effectType == 1),createTime = os.time()})
        end
        func(go)
    end)
end



--- 加载预设_挂在bingoContainer层级
---@param prefabName 预设名字
---@param targetObj 目标物体_保持和目标同步
---@param cardId 卡牌ID
---@param effectType 特效类型0普通_1bingo_2Jackpot
function BattleEffectCache:GetFixedPrefabFromCache(prefabName,targetObj, func,cardId,effectType,addCover,parentLayer)
    Cache.load_prefabs(AssetList[prefabName],prefabName,function(obj)
        local go = fun.get_instance(obj)
        fun.set_parent(go,bingoContainer,true)
        fun.set_same_position_with(go,targetObj)
        if targetObj then
            fun.set_same_position_with(go,targetObj)
        end
        func(go)
    end)
end

---  加载技能特效预设_放置在skillContainer层级_设置了回收时间
------@param prefabName 预设名字
-----@param targetObj 目标物体_保持和目标同步
-----@param recycleTime 回收时间
-----@param cardId 卡牌ID
---@param effectType int32 特效类型0普通_1bingo_2Jackpot
function BattleEffectCache:GetSkillPrefabFromCache(prefabName, targetObj, func, recycleTime, cardId, effectType, addCover, sameTargetWorldScale)
    local go = BattleEffectPool:Get(prefabName)
    if go then
        fun.set_parent(go, skillContainer, true)
        fun.set_same_position_with_but_z_zero(go, targetObj)
        if targetObj then
            if not cardId then
                cardId = -1
            else
                cardId = tonumber(cardId)
            end
            if not effectType then
                effectType = 0
            end
            local coverObj = nil
            if addCover then
                --fun.set_active(obj,false)
                coverObj = UnityEngine.GameObject.New("Cover")
                fun.set_parent(coverObj, go.transform.parent, true)
                fun.set_same_position_with(coverObj, targetObj)
                fun.set_parent(go, coverObj, true)
            end
            fun.set_active(go, true)
            table.insert(bindEffectes, { target = targetObj, go = go, cardId = cardId, isJackpot = (effectType == 2)
            , coverObj = coverObj, isBingo = (effectType == 1), createTime = os.time() })
            if sameTargetWorldScale then
                fun.set_same_world_scale_with(go, targetObj)
            end
        end
        if func then
            func(go)
        end
        if recycleTime and recycleTime > 0 then
            BattleEffectPool:DelayRecycle(prefabName, go, recycleTime)
        end
    else
        Cache.load_prefabs(AssetList[prefabName], prefabName, function(obj)
            local go = fun.get_instance(obj)
            fun.set_parent(go, skillContainer, true)
            fun.set_same_position_with_but_z_zero(go, targetObj)
            if targetObj then
                if not cardId then
                    cardId = -1
                else
                    cardId = tonumber(cardId)
                end
                if not effectType then
                    effectType = 0
                end
                local coverObj = nil
                if addCover then
                    --fun.set_active(obj,false)
                    coverObj = UnityEngine.GameObject.New("Cover")
                    fun.set_parent(coverObj, go.transform.parent, true)
                    fun.set_same_position_with(coverObj, targetObj)
                    fun.set_parent(go, coverObj, true)
                end
                fun.set_active(go, true)
                table.insert(bindEffectes, { target = targetObj, go = go, cardId = cardId, isJackpot = (effectType == 2)
                , coverObj = coverObj, isBingo = (effectType == 1), createTime = os.time() })
                if sameTargetWorldScale then
                    fun.set_same_world_scale_with(go, targetObj)
                end
            end
            if func then
                func(go)
            end
            if recycleTime and recycleTime > 0 then
                BattleEffectPool:DelayRecycle(prefabName, go, recycleTime)
            end
        end, true)
    end
end

---  加载小丑特效预设_放置在skillContainer层级_设置了回收时间
------@param prefabName 预设名字
-----@param targetObj 目标物体_保持和目标同步
-----@param recycleTime 回收时间
-----@param cardId 卡牌ID
------@param effectType 特效类型0普通_1bingo_2Jackpot
function BattleEffectCache:GetJokerPrefabFromCache(prefabName,func,recycleTime,cardId,effectType,addCover)
    Cache.load_prefabs(AssetList[prefabName],prefabName,function(obj)
        local go = fun.get_instance(obj)
        local targetObj = skillContainer
        fun.set_parent(go,skillContainer,true)
        fun.set_same_position_with_but_z_zero(go,targetObj)
        if targetObj then
            if not cardId then  cardId = -1 else cardId = tonumber(cardId) end
            if not effectType then  effectType = 0 end
            local coverObj = nil
            if addCover then
                coverObj = UnityEngine.GameObject.New("Cover")
                fun.set_parent(coverObj,go.transform.parent,true)
                fun.set_same_position_with(coverObj,targetObj)
                fun.set_parent(go,coverObj,true)
            end
            fun.set_active(go,true)
            table.insert(bindEffectes,{target = targetObj,go = go,cardId = cardId,isJackpot = (effectType == 2)
            ,coverObj = coverObj, isBingo =(effectType == 1),createTime = os.time() })
        end
        if func then func(go) end
        if recycleTime and recycleTime > 0 then Destroy(go,recycleTime) end
    end)
end

function BattleEffectCache:Release()
    bindEffectes= {}
    skillContainer = nil
    bingoContainer = nil
end

function BattleEffectCache:AddBindEffect(go, targetObj, cardId, effectType)
    cardId = cardId and tonumber(cardId) or -1
    effectType = effectType or 0
    table.insert(bindEffectes,{
        target = targetObj,
        go = go,
        cardId = cardId,
        isJackpot = (effectType == 2),
        isBingo =(effectType == 1),
        createTime = os.time() 
    })
end

function BattleEffectCache:RemoveBindEffect(go, cardId)
    local find, key = table.find(bindEffectes, function(k, v)
        return v.go == go and v.cardId == cardId
    end)
    if find and key then
        table.remove(bindEffectes, key)
    end 
end

function BattleEffectCache:RemoveBindEffect2(go)
    if bindEffectes then
        local find, key = table.find(bindEffectes, function(k, v)
            return v.go == go
        end)
        if find and key then
            table.remove(bindEffectes, key)
        end
    end
end

---@see  设置了绑定目标的特效_刷新到相应绑定目标的最新位置
function BattleEffectCache:FollowTargetObj()
    for i = 1, #bindEffectes do
        if  not Util.IsNull(bindEffectes[i].target)  and not Util.IsNull(bindEffectes[i].coverObj) then
            fun.set_same_position_with(bindEffectes[i].coverObj,bindEffectes[i].target)
        elseif not Util.IsNull(bindEffectes[i].target)  and not Util.IsNull(bindEffectes[i].go) and not (bindEffectes[i].go.transform.parent == bindEffectes[i].target.transform) then
            fun.set_same_position_with(bindEffectes[i].go,bindEffectes[i].target)
        end
    end

    for i = #bindEffectes, 1, -1 do
        if Util.IsNull(bindEffectes[i].target)  or Util.IsNull(bindEffectes[i].go) then
            if  not Util.IsNull(bindEffectes[i].coverObj) then Destroy(bindEffectes[i].coverObj) end
            table.remove(bindEffectes,i)
        end
    end
end

---@see 检查有绑定关系的特效是否全部隐藏
function BattleEffectCache:CheckEffectAllHide()
    local allHide = true
    for i = #bindEffectes, 1, -1 do
        if allHide and not Util.IsNull(bindEffectes[i].target) and not Util.IsNull(bindEffectes[i].go) then
            allHide = false
        end
        if Util.IsNull(bindEffectes[i].target) or Util.IsNull(bindEffectes[i].go) then
            if  bindEffectes[i].coverObj  and not Util.IsNull(bindEffectes[i].coverObj )  then Destroy(bindEffectes[i].coverObj) end
            table.remove(bindEffectes, i)
        end
    end
    return allHide
end

--- 检查有绑定关系的特效是否全部隐藏_忽略jackpot效果
function BattleEffectCache:CheckEffectAllHideWithoutJackpot()
    local allHide = true
    local gameType = ModelList.BattleModel:GetGameCityPlayID()
    local jackpotMinAliveTime = Csv.GetData("new_game_effect_cache",gameType,"jackpot_effect_min_alive_time")*0.001 or 0
    for i = #bindEffectes, 1, -1 do
        if allHide and not Util.IsNull(bindEffectes[i].target) and not Util.IsNull(bindEffectes[i].go) then
            if  (not bindEffectes[i].isJackpot )   or    ( bindEffectes[i].isJackpot and os.time() - bindEffectes[i].createTime < jackpotMinAliveTime) then
                allHide = false
            end
        end
        if Util.IsNull(bindEffectes[i].target) or Util.IsNull(bindEffectes[i].go) then
            if  bindEffectes[i].coverObj  and not Util.IsNull(bindEffectes[i].coverObj )  then Destroy(bindEffectes[i].coverObj) end
            table.remove(bindEffectes, i)
        end
    end
    return allHide
end

--- 检查有绑定关系的特效是否全部隐藏_忽略jackpot效果
function BattleEffectCache:CheckEffectAllHideWithoutBingo()
    local allHide = true
    local gameType = ModelList.BattleModel:GetGameCityPlayID()
    local bingoMinAliveTime = Csv.GetData("new_game_effect_cache",gameType,"bingo_effect_min_alive_time")*0.001 or 0
    for i = #bindEffectes, 1, -1 do
        if allHide and not Util.IsNull(bindEffectes[i].target) and not Util.IsNull(bindEffectes[i].go)    then
            if  (not bindEffectes[i].isBingo )   or    ( bindEffectes[i].isBingo and os.time() - bindEffectes[i].createTime < bingoMinAliveTime) then
                allHide = false
            end
        end
        if Util.IsNull(bindEffectes[i].target) or Util.IsNull(bindEffectes[i].go) then
            if  bindEffectes[i].coverObj  and not Util.IsNull(bindEffectes[i].coverObj )  then Destroy(bindEffectes[i].coverObj) end
            table.remove(bindEffectes, i)
        end
    end
    return allHide
end

--- 检查有单卡绑定关系的特效是否全部隐藏
function BattleEffectCache:CheckCardHideAllEffect(cardId)
    local allHide = true
    cardId = tonumber(cardId)
    for i = #bindEffectes, 1, -1 do
        if allHide and cardId == bindEffectes[i].cardId and  not Util.IsNull(bindEffectes[i].target) and 
                not Util.IsNull(bindEffectes[i].go)
                and not  bindEffectes[i].isJackpot then
            allHide = false
        end
        if Util.IsNull(bindEffectes[i].target) or Util.IsNull(bindEffectes[i].go) then
            if  bindEffectes[i].coverObj  and not Util.IsNull(bindEffectes[i].coverObj )  then Destroy(bindEffectes[i].coverObj) end
            table.remove(bindEffectes, i)
        end
    end
    return allHide
end

--- 检查有单卡绑定关系的特效是否全部隐藏
function BattleEffectCache:CardHideAllEffectWithoutJackpot(cardId)
    local allHide = true
    cardId = tonumber(cardId)
    for i = #bindEffectes, 1, -1 do
        if allHide and cardId == bindEffectes[i].cardId and  not Util.IsNull(bindEffectes[i].target) and
                not Util.IsNull(bindEffectes[i].go)  and not  bindEffectes[i].isJackpot then
            allHide = false
        end
        if Util.IsNull(bindEffectes[i].target) or Util.IsNull(bindEffectes[i].go) then
            if  bindEffectes[i].coverObj  and not Util.IsNull(bindEffectes[i].coverObj )  then Destroy(bindEffectes[i].coverObj) end
            table.remove(bindEffectes, i)
        end
    end
    return allHide
end

--- 检查有单卡绑定关系的特效是否全部隐藏
function BattleEffectCache:CardHideAllBindEffect()
    local gameType = ModelList.BattleModel:GetGameCityPlayID()
    local settle_ignore_effect_type = Csv.GetData("new_game_effect_cache",gameType,"settle_ignore_effect_type")
    if settle_ignore_effect_type == 1 then
        for i = #bindEffectes, 1, -1 do
            if  not bindEffectes[i].isBingo then
                fun.set_active(bindEffectes[i].go,false)
            end
        end
    else  --if settle_ignore_effect_type == 2 then
        for i = #bindEffectes, 1, -1 do
            if  not bindEffectes[i].isJackpot then
                fun.set_active(bindEffectes[i].go,false)
            end
        end
    end
end

--- 检查有单卡绑定关系的特效是否全部隐藏
function BattleEffectCache:GetCardJackPotEffect(cardId)
    cardId = tonumber(cardId)
    for i = #bindEffectes, 1, -1 do
        if  cardId == bindEffectes[i].cardId and bindEffectes[i].isJackpot then
            return bindEffectes[i].go
        end
    end
    return nil
end

--- 优先从缓存池中获取特效
--- 获取不到则从资源中加载
function BattleEffectCache:GetPrefabFromPoolOrCache(prefabName,targetObj, func,cardId,effectType,addCover,parentLayer)
    local go =  BattleEffectPool:Get(prefabName)
    if  fun.is_null(go) then
        Cache.load_prefabs(AssetList[prefabName],prefabName,function(obj)
            local go = fun.get_instance(obj)
            fun.set_parent(go,bingoContainer,true)
            if targetObj then
                if not cardId then  cardId = -1 else cardId = tonumber(cardId) end
                if not effectType then  effectType =0 end
                local coverObj = nil
                if addCover then
                    fun.set_active(obj,false)
                    coverObj = UnityEngine.GameObject.New("Cover")
                    fun.set_parent(coverObj,obj.transform.parent,true)
                    fun.set_same_position_with(coverObj,targetObj)
                    fun.set_parent(obj,coverObj,true)
                else
                    fun.set_same_position_with(go,targetObj)
                end
                table.insert(bindEffectes,{target = targetObj,go = go,cardId = cardId,isJackpot = (effectType == 2),
                                           coverObj = coverObj,isBingo = (effectType == 1),createTime = os.time()})
            end
            func(go)
        end)
    else
        fun.set_parent(go,bingoContainer,true)
        if targetObj then
            if not cardId then  cardId = -1 else cardId = tonumber(cardId) end
            if not effectType then  effectType =0 end
            local coverObj = nil
            if addCover then
                coverObj = UnityEngine.GameObject.New("Cover")
                fun.set_parent(coverObj,go.transform.parent,true)
                fun.set_same_position_with(coverObj,targetObj)
                fun.set_parent(go,coverObj,true)
            else
                fun.set_same_position_with(go,targetObj)
            end
            table.insert(bindEffectes,{target = targetObj,go = go,cardId = cardId,isJackpot = (effectType == 2),
                                       coverObj = coverObj,isBingo = (effectType == 1),createTime = os.time()})
        end
        func(go)
    end
end

-------------BingoBang----Start-------------------------------------------------

function BattleEffectCache:GetPrefabFromPoolOrCache_BingoBang(prefabName, cb)
    local cacheGo = BattleEffectPool:Get(prefabName)
    if cacheGo then
        fun.SafeCall(cb, cacheGo)
    else
        Cache.load_prefabs(AssetList[prefabName], prefabName, function(obj)
            if not IsNull(obj) then
                fun.set_active(obj, false)
                local go = fun.get_instance(obj)
                fun.SafeCall(cb, go)
            else
                fun.SafeCall(cb)
            end
        end, true)
    end
end

function BattleEffectCache:GetCachedPrefab_BingoBang(cardId, prefabName, options)
    options = options or {}
    local targetObj, recycleTime, cb = options.targetObj, options.recycleTime, options.cb
    local parentContainerType = options.parentContainerType
    
    BattleEffectCache:GetPrefabFromPoolOrCache_BingoBang(prefabName, function(go)
        if IsNull(go) then
            fun.SafeCall(cb)
            return
        end

        BattleEffectCache:SetEffectPrefabParent_BingoBang(cardId, go, parentContainerType)
        
        if not IsNull(targetObj) then
            fun.set_same_position_with_but_z_zero(go, targetObj)
        end

        fun.set_active(go, true)
        fun.SafeCall(cb, go)
        if recycleTime and recycleTime > 0 then
            BattleEffectPool:DelayRecycle(prefabName, go, recycleTime)
        end
    end)
end

function BattleEffectCache:GetSkillPrefab_BingoBang(cardId, prefabName, targetObj, recycleTime, cb)
    BattleEffectCache:GetPrefabFromPoolOrCache_BingoBang(prefabName, function(go)
        if IsNull(go) then
            fun.SafeCall(cb)
            return
        end
        
        BattleEffectCache:SetEffectPrefabParent_BingoBang(cardId, go, BingoBangEntry.BattleContainerType.BingoEffectContainer)
        fun.set_same_position_with_but_z_zero(go, targetObj)
        fun.set_active(go, true)
        fun.SafeCall(cb, go)
        if recycleTime and recycleTime > 0 then
            BattleEffectPool:DelayRecycle(prefabName, go, recycleTime)
        end
    end)
end

function BattleEffectCache:SetEffectPrefabParent_BingoBang(cardId, go, parentContainerType)
    if not cardId then
        fun.set_parent(go, skillContainer, true)
        return
    end

    parentContainerType = parentContainerType or BingoBangEntry.BattleContainerType.BingoEffectContainer
    
    cardId = tonumber(cardId)
    local cardInput = BattleModuleList.GetModule("CardInput")
    if not cardInput then
        fun.set_parent(go, skillContainer, true)
        return
    end
    
    local cardView = ModelList.BattleModel:GetCurrBattleView():GetCardView()
    local par = cardView:GetEffectPlayRoot(cardId, parentContainerType)
    fun.set_parent(go, par, true)
    
    --if cardInput:GetColliderStateByID(cardId) then
    --    fun.set_parent(go, skillContainer, true)
    --else
    --    --卡牌在小卡中展示
    --    local cardView = ModelList.BattleModel:GetCurrBattleView():GetCardView()
    --    local cardObj = cardView:GetCardMap(cardId)
    --    fun.set_parent(go, cardObj, true)
    --end
end

-------------BingoBang----End--------------------------------------------------
