---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2023/2/8 17:19
---
---  4个位置被影响一定次数

local BaseBingoRule =  require("Combat.Machine.CalculateBingo.BaseBingoRule")

local SingleWolfBingoRule = BaseBingoRule:New("SingleWolfBingoRule")
local this = SingleWolfBingoRule
setmetatable(SingleWolfBingoRule, {__index = BaseBingoRule})

local wolfData = {}    --缓存狼人锁链解锁数据
local MaxBreakCount = 4  --每个狼人解锁所需数量
local wolfCellPos = {7, 9, 17, 19}

function SingleWolfBingoRule:Start(loadData,wish_item)
    wolfData = {}

    table.each(loadData.cardsInfo, function(cardInfo)
        local cardID = cardInfo.cardId
        wolfData[cardID] = {
            breakData = { },    --解锁锁链数据
            bingo = {},         --能形成bingo的酒杯ID
            jackpot = 0         --  0没有jackpot  1 形成了jackpot
        }
        table.each(wolfCellPos, function(cellIndex)
            wolfData[cardID].breakData[cellIndex] = 0
        end)
    end)
    
    --达成Bingo的解锁数量
    MaxBreakCount = {}
    local ruleId = Csv.GetData("city_play",ModelList.CityModel.GetPlayIdByCity(),"bingo_rule_id")[1]
    local ruleData = Csv.GetData("new_bingo_rule",ruleId[1],"params")
    table.each(ruleData, function(data)
        local cellPos = ConvertServerPos(data[1])
        MaxBreakCount[cellPos] = data[2]
    end)
    
    this:InitData()
    this.model = ModelList.BattleModel:GetCurrModel()
end

function SingleWolfBingoRule:CalculateBingo(cardId, cellIndex, ...)
    local totalBingoInfoList = {}
    local newBingoInfoList = {}
    local num = {...}
    
    local data = wolfData[cardId]
    if #data.bingo > 0 then
        local bingoInfo = this:CreateBingoInfo(this.BingoType.BINGO, num, cardId)
        bingoInfo.wolfPos = cellIndex
        table.insert(newBingoInfoList, bingoInfo)
        data.bingo = {}
    end
    if #newBingoInfoList > 0 then
        fun.merge_array(totalBingoInfoList,newBingoInfoList)
    end

    if this:CalculateJackpot(cardId) then
        local bingoInfo = { type = this.BingoType.JACKPOT, numbers = num,
                            cardId = cardId, totolCount = this.totalBingoCount[cardId], th = 0}
        table.insert(totalBingoInfoList,bingoInfo)
    end
    if #totalBingoInfoList >0 then
        Event.Brocast(EventName.Player_Bingo_Reduce_Bingoleft, totalBingoInfoList, cardId)
    end
end

function SingleWolfBingoRule:OnDataChange(cardId, cellIndex, ...)
    local arg = {...}
    local breakCount = arg[1]
    local breakData = wolfData[cardId].breakData

    if breakData[cellIndex] < MaxBreakCount[cellIndex] then
        breakData[cellIndex] = breakCount
        if breakData[cellIndex] >= MaxBreakCount[cellIndex] then
            table.insert(wolfData[cardId].bingo, 0)
        end
    end
end

function SingleWolfBingoRule:CalculateJackpot(cardId)
    local data = wolfData[cardId]
    if data.jackpot == 1 then 
        return false
    end
    
    local allBingo = true
    table.each(data.breakData, function(count, cellIndex)
        if count and MaxBreakCount[cellIndex] then
            if count < MaxBreakCount[cellIndex] then
                allBingo = false
            end
        end
    end)
    return allBingo
end

function SingleWolfBingoRule:GetTotalBingoCount(cardId)
    local data, ret = wolfData[cardId], 0
    table.each(data.breakData, function(count, cellIndex)
        if count and MaxBreakCount[cellIndex] then
            if count >= MaxBreakCount[cellIndex] then
                ret = ret + 1
            end
        end
    end)
    return ret
end

return this