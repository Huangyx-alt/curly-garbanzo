---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2021/8/24 11:03
---
local CityModel = BaseModel:New("CityModel")
local this = CityModel

local curCityId = 1       --当前的cityid
local curCityPlayID = nil  -- 当前city
local lastCityPlayID = nil -- 当前city
local maxCity = 1
local maxAutoCity = 1
local temCityId = -1      --暂时存放切换的cityid，切换成功再赋给curCityId 03/17 临时的选城才会变
local enterCostCoin = nil --当前进入游戏需要消耗的金币
local powerupCost = nil   --点前购买powerup需要消耗的钻石
local cardNumber = 1      --选择的卡盘数量
local cityResourceInfo = nil

local powerCardList = {} --保存已购买未使用的powerup卡片 0516 改为2维数组
local powerCardPage = {} --不同模式下的当前页  0516 改为2维数组
local betRate = {}       --记录当前倍率

local powerupCardId = nil
local recommendPlay = {}
local recGameResBaseUrl = {}
local previous_play_info = {}
local currentPowerLevel = 1 --当前得powerUp 得 界面等级
local isTraSGP = nil
local max_open_city = 1
local powerUpRange = {}
local DownloadManagerList = {}

local curBetRate = nil

local MAX_BAT_RATE = 10 --此处已写死
function MaxBatRate()
    return MAX_BAT_RATE
end

-- function GetCurrentLevelMaxBatRate()
--     return Csv.GetMaxBetRate()
-- end

function CityModel:InitData()
    --Event.AddListener(EventName.Event_enter_bingogame,self.EnterBingoGame)
    --Event.AddListener(EventName.Event_Enter_Hangup,self.EnterBingoGame)
end

function CityModel:SetLoginData(data)
    this:SetCurrentCity(data.roleInfo)
    this:SetCityData(data.cityInfo)
    this:SetRecommendPlayData(data.recommendPlay)
    this:SetrecGameResBaseUrl(data.recGameResBaseUrl)
    this:CheckDebugPlayer(data.debugLevel)
end

function CityModel:SetDataUpdate(data, params)
    if params == "roleInfo" then
        this:UpdateCity(data)
    elseif params == "cityInfo" then
        this:SetCityData(data.cityInfo)
        Event.Brocast(EventName.Event_cityResource_change)
    end
end

--每次遍历比较耗性能，多一张表储存
function CityModel:GetPowerUpRange()
    if powerUpRange == nil or #powerUpRange == 0 then
        powerUpRange = Csv.GetPowerupRange()
    end

    return powerUpRange
end

function CityModel:CheckIsJokerOpen(playId)
    if powerUpRange == nil or #powerUpRange == 0 then
        powerUpRange = Csv.GetPowerupRange()
    end

    return powerUpRange[playId][4]
end

function CityModel:SetCurrentCity(data)

end

--判断倍数是否开放
function CityModel:IsBatRateOpen(betRate, city)
    local PlayID = self.GetPlayIdByCity()
    local openLevel = Csv.GetLevelJPOpenByPlayId(PlayID, betRate) --Csv.GetLevelJPOpenById(cityID,betRate) --分支特用--Csv.GetLevelJPOpenById(cityID,betRate)
    local isRUser = false

    if ModelList.PlayerInfoModel:GetUserType() and (UserTypeBigR == ModelList.PlayerInfoModel:GetUserType() or
            UserTypeMidR == ModelList.PlayerInfoModel:GetUserType() or UserTypeSmaR == ModelList.PlayerInfoModel:GetUserType()) then
        isRUser = true
    end

    if isRUser then
        openLevel = Csv.GetLevelJPOpenByPlayIdPay(PlayID, betRate)
    end

    --ultra 强制开启所有下注选项
    if ModelList.UltraBetModel:IsActivityValidForCurPlay() then
        return true, openLevel
    end

    return ModelList.PlayerInfoModel:GetLevel() >= openLevel, openLevel
end

--

function CityModel:GetMaxRateOpen(city)
    local data = ModelList.BetConfigModel.GetUseBetConfig()
    if data and data.curBet then
        return data.curBet[GetTableLength(data.curBet)]
    end
    return nil
end

function CityModel:UpdateCity(data)
    if data then
        maxCity = 1
        maxAutoCity = 1
        local LevelOPen = Csv.GetCityLevelOpen(PLAY_TYPE.PLAY_TYPE_NORMAL)       --正常玩法的
        local LevelOPen2 = Csv.GetCityLevelOpen(PLAY_TYPE.PLAY_TYPE_AUTO_TICKET) --挂机玩法的

        for id, v in pairs(LevelOPen) do
            if data.level >= v and id >= maxCity then
                maxCity = id
            end
        end

        for id, v in pairs(LevelOPen2) do
            if data.level >= v and id >= maxCity then
                maxAutoCity = id
            end
        end
    end
end

function CityModel:GetMaxCity()
    return maxCity
end

function CityModel:GetMaxAutoCity()
    return maxAutoCity
end

--城市机台 1/2/3/4
--vip大厅机台 0
function CityModel:GetCity()
    return curCityId
end

function CityModel.SetPlayId(playId)
    if playId == nil then
        log.r("CityModel.SetPlayId   nil")
    else
        log.r("CityModel.SetPlayId   " .. playId)
    end

    curCityPlayID = playId
    ModelList.SmallGameModel:UpdateCityPlayId(playId)
end

--城市机台 1
--vip大厅机台 2/3/4/5/6
function CityModel.GetPlayIdByCity(city)
    return curCityPlayID
end

------------------------------------Winzone使用------------------------------------Begin
function CityModel.RecordLastPlayId()
    log.log("CityModel.RecordLastPlayId", curCityPlayID)
    lastCityPlayID = curCityPlayID
end

function CityModel.ClearLastPlayId()
    log.log("CityModel.ClearLastPlayId", curCityPlayID)
    lastCityPlayID = nil
end

function CityModel.GetLastPlayId()
    log.log("CityModel.GetLastPlayId", lastCityPlayID)
    return lastCityPlayID
end

------------------------------------Winzone使用------------------------------------End

function CityModel.GetCurPlayType()
    if not curCityPlayID then
        return
    end

    local playType = Csv.GetData("city_play", curCityPlayID, "play_type")
    return playType
end

function CityModel.CheckCurTypeIs(playType)
    if not playType then
        return
    end

    local curPlayType = this.GetCurPlayType()
    return curPlayType == playType
end

function CityModel:GetBetValue()

    return curBetRate
end

function CityModel:GetBetRate()
    if not curBetRate then
        --bet数据未初始化
        self:SetUsedBetRate()
    end
    local data = ModelList.BetConfigModel.GetUseBetConfig()
    for k ,v in pairs(data.curBet) do
        if v == curBetRate then
            return k
        end
    end
    log.r("bet参数异常" , data , curBetRate)
end

function CityModel:IsMaxBetRate()
    return MAX_BAT_RATE == this:GetBetRate()
end

function CityModel:GetPowerupId() --  没有用到了 废弃
    -- local page = self:GetPage()
    -- local playId = self.GetPlayIdByCity()
    -- if powerCardList and powerCardList[playId] and powerCardList[playId][page] then
    --     return powerCardList[playId][page]["id"]
    -- end
    return 0
end

function CityModel:GetPowerupGear()
    ---獲取當前卡牌的擋數
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local page = self:GetPage()
    local playId = self.GetPlayIdByCity()
    local cardNum = flag and self.GetCardNumber() or 0
    local temCardList = nil
    if powerCardList[playId] and powerCardList[playId][cardNum] and powerCardList[playId][cardNum][currentPowerLevel] then
        temCardList = powerCardList[playId][cardNum][currentPowerLevel]
    end

    local cards = {}
    local jokerCard = {}
    local cardCount = 0
    local cardId = 0
    if temCardList and temCardList[page] then
        cards = temCardList[page]["powerups"]
        jokerCard = temCardList[page]["jokerPowerups"]
        cardId = temCardList[page]["id"]
    end
    if cards then
        for key, value in pairs(cards) do
            if value > 0 then
                cardCount = cardCount + 1
            end
        end
    end

    if currentPowerLevel and currentPowerLevel == 4 then
        if 6 == cardCount then
            return BuyPowerCardGenre.onegear, cardId
        elseif 9 == cardCount and #jokerCard == 0 then
            return BuyPowerCardGenre.twogear, cardId
        elseif 9 == cardCount and #jokerCard > 0 then
            return BuyPowerCardGenre.threegear, cardId
        end
    else
        if 3 == cardCount then
            return BuyPowerCardGenre.onegear, cardId
        elseif 6 == cardCount then
            return BuyPowerCardGenre.twogear, cardId
        elseif 9 == cardCount then
            return BuyPowerCardGenre.threegear, cardId
        end
    end

    return BuyPowerCardGenre.nonegear, cardId
end

--检查是否有足够钱
function CityModel:CheckHaveNoEnoughCoin()
    ModelList.CityModel:CalculatePlayCardBaseCost()
    local resourceValue = ModelList.ItemModel.getResourceNumByType(Resource.coin)
    local cardNum = ModelList.CityModel:GetCardNumber()
    local cost = ModelList.CityModel:CheckPlayCardRealCost(cardNum, nil)

    if resourceValue < cost then
        return true, cost
    end

    return false
end

function CityModel:SetBetRateStep(rate, city)
    log.log("bet数据问题 SetBetRateStep ", rate)
    local lastBetRate = self:GetBetValue()
    local data = ModelList.BetConfigModel.GetUseBetConfig()
    local isUseUnlockBet = false
    for k ,v in ipairs(data.curBet) do
        if v == lastBetRate and data.curBet[k+rate] then
            isUseUnlockBet = true
            curBetRate = data.curBet[k + rate]
            break
        end
    end
    if not isUseUnlockBet then
        --增加bet 加到未解锁的bet
        if rate > 0 then
            if data and data.nextBet and data.nextBet[1] then
                curBetRate = data.nextBet[1]
            else
                log.log("错误 没有能继续解锁的bet " , curBetRate)
            end
        else
            --解锁bet 从未解锁bet减少到最大已解锁bet
            curBetRate = data.curBet[GetTableLength(data.curBet)]
        end
    end
end

function CityModel:SetUsedBetRate()
    local betIndex = ModelList.BetConfigModel.ReadSelectBattleIndex()
    local data = ModelList.BetConfigModel.GetUseBetConfig()
    if data.curBet[betIndex] then
        this:SetBetRate(data.curBet[betIndex])
    end
end

--flag 必须第一次或者不需要第一次
function CityModel:SetBetRate(rate, city, flag)
    log.log("bet数据问题 SetBetRate ", rate)
    curBetRate = rate
    --local playId = self.GetPlayIdByCity()
    --local playInfo = ModelList.PlayerInfoModel:GetUserInfo()
    --local readValue = fun.read_value(playInfo.uid .. "_rate_" .. playId .. "_level_" .. playInfo.level, nil)
    --if not readValue and flag ~= nil then
    --    return
    --end
    --
    --if betRate[playId] ~= nil and flag ~= nil then
    --    return
    --end
    --
    --betRate[playId] = math.max(math.min(rate, MAX_BAT_RATE), 1)
    --fun.save_value(playInfo.uid .. "_rate_" .. playId .. "_level_" .. playInfo.level, betRate[playId])
end

function CityModel:GetInitialBetRate()
    local playInfo = ModelList.PlayerInfoModel:GetUserInfo()
    local playId = self.GetPlayIdByCity()
    local default = nil --  Csv.GetControlId(playId,playInfo.level)
    local isRUser = false


    if ModelList.PlayerInfoModel:GetUserType() and (UserTypeBigR == ModelList.PlayerInfoModel:GetUserType() or
            UserTypeMidR == ModelList.PlayerInfoModel:GetUserType() or UserTypeSmaR == ModelList.PlayerInfoModel:GetUserType()) then
        isRUser = true
    end

    if isRUser then --
        default = Csv.GetMaxRateOpenByPlayidPay(playId, playInfo.level)
    else
        default = Csv.GetMaxRateOpenByPlayid(playId, playInfo.level)
    end

    local betrate = fun.read_value(playInfo.uid .. "_rate_" .. playId .. "_level_" .. playInfo.level, default)

    return betrate
end

--获取城市的相应的倍数
function CityModel:getBetRateSection(cityID, level)
    if this:GetEnterGameMode() == PLAY_TYPE.PLAY_TYPE_NORMAL then
        if cityID == 1 then
            return Csv.GetControlId(104, level)
        elseif cityID == 2 then
            return Csv.GetControlId(105, level)
        elseif cityID == 3 then
            return Csv.GetControlId(106, level)
        end
    else
        return Csv.GetControlId(107, level)
    end
end

--是否已解锁bet场景
function CityModel:GetCanStartGame()
    local betRate = self:GetBetRate()
    log.log("bet数据问题 GetCanStartGame ", betRate)
    return self:IsBatRateOpen(betRate)
end

---
---进入游戏前，根据城市、倍率计算的入场费
---
function CityModel:SetCostCoin(card, value)
    if enterCostCoin == nil then
        enterCostCoin = {}
    end
    if card then
        enterCostCoin[card] = value
    end
end

---
---获取当前的入场费
function CityModel:GetCostCoin(card)
    local cardtype = card or cardNumber
    local costCoin = 0
    if cardtype then
        if enterCostCoin and enterCostCoin[cardtype] then
            costCoin = enterCostCoin[cardtype]
        end
    end

    return costCoin
end

---【1.24】购卡费用随玩家等级提升而变化
function CityModel:GetCostCoinCoefficient(isUltrabet, betRate)
    --local coefficient = 1
    --local currLevel = ModelList.PlayerInfoModel:GetLevel()
    --local currPlayId = this.GetPlayIdByCity()
    --for i = 1, #Csv.level_coefficient do
    --    if currLevel >= Csv.level_coefficient[i].level[1] and currLevel <= Csv.level_coefficient[i].level[2] and
    --        fun.is_include(currPlayId, Csv.level_coefficient[i].cityplay_id) then
    --        if isUltrabet then
    --            if Csv.level_coefficient[i].ultrabet_valve == 1 then
    --                coefficient = Csv.level_coefficient[i].coefficient[betRate] * 0.01
    --                break
    --            end
    --        else
    --            coefficient = Csv.level_coefficient[i].coefficient[betRate] * 0.01
    --            break
    --        end
    --    end
    --end
    --return coefficient
end

function CityModel:CalculatePlayCardBaseCost(gameMode)
    --local betRate = this:GetBetRate()
    ----判断是否可以得到当前betRate 跟活动时间有关
    --local MaxBetRate = this:GetMaxRateOpen()
    ----如果大于bet Rate  应该平
    --if betRate > MaxBetRate then
    --    betRate = MaxBetRate
    --end
    --
    --local playId = this.GetPlayIdByCity()
    --local card1spend, card2spend, card3spend
    --
    ----Ultra开启后的固定cost
    --local isUltraBetOpen = ModelList.UltraBetModel:IsActivityValidForCurPlay()
    --local coefficient = this:GetCostCoinCoefficient(isUltraBetOpen, betRate)
    --if isUltraBetOpen then
    --    local baseCostInUltra = ModelList.UltraBetModel:GetSingleCardCostByBet()
    --    card1spend = baseCostInUltra * 1 * coefficient
    --    card2spend = baseCostInUltra * 2 * coefficient
    --    card3spend = baseCostInUltra * 4 * coefficient
    --else
    --    local cardspend = Csv.GetData("city_play", playId, "cardspend")
    --    local betspend = Csv.GetData("city_play", playId, "betspend")
    --    local rate = 100
    --    if betRate > 1 then
    --        rate = betspend[betRate]
    --    end
    --    card1spend = cardspend[1][2] * rate / 100 * coefficient;
    --    card2spend = cardspend[2][2] * rate / 100 * coefficient;
    --    card3spend = cardspend[3][2] * rate / 100 * coefficient;
    --end
    --
    --
    --if (gameMode or this:GetEnterGameMode()) ~= PLAY_TYPE.PLAY_TYPE_AUTO_TICKET then
    --    this:SetCostCoin(CardGenre.onecard, card1spend)
    --    this:SetCostCoin(CardGenre.twocard, card2spend)
    --    this:SetCostCoin(CardGenre.fourcard, card3spend)
    --else
    --    if isUltraBetOpen then
    --        this:SetCostCoin(CardGenre.fourcard, card1spend * 4)
    --        this:SetCostCoin(CardGenre.sixcard, card1spend * 6)
    --        this:SetCostCoin(CardGenre.eightcard, card1spend * 8)
    --    else
    --        this:SetCostCoin(CardGenre.fourcard, card1spend)
    --        this:SetCostCoin(CardGenre.sixcard, card2spend)
    --        this:SetCostCoin(CardGenre.eightcard, card3spend)
    --    end
    --end
    --
    --return betRate
end

function CityModel:CalculatePlayCardBaseCostPowerup(betRate)
    betRate = betRate or this:GetBetRate()
    local playId = this.GetPlayIdByCity()
    local cardspend = Csv.GetData("city_play", playId, "cardspend")
    local betspend = Csv.GetData("city_play", playId, "betspend")
    local rate = 1
    if betRate > 1 then
        rate = betspend[betRate] / 100
    end
    local card1spend = cardspend[1][2] * rate

    return card1spend;
end

function CityModel:CheckPlayCardRealCost(genre, discount_id)
    local cost = this:GetCostCoin(genre or this:GetCardNumber())
    if cost then
        --选择拥有的马上过期的打折道具
        local data = ModelList.ItemModel:GetItemByType(ItemType.coin_DisCount)
        local tmpData
        local time = 9999999
        if fun.table_len(data) > 0 then
            for _, v in ipairs(data) do
                if ((v.value - os.time()) > 0) and (v.value - os.time() < time) then
                    time = v.value - os.time()
                    tmpData = v
                end
            end
        end

        if not tmpData then
            --指定打折道具
            if discount_id then
                local saleoff = Csv.GetData("coupon", discount_id, "saleoff")
                cost = math.max(0, cost - cost * (saleoff / 100))
            end
        else
            local result = Csv.GetData("item", tmpData.id, "result")
            local disCount = result[2] or 0
            cost = math.max(0, cost - cost * (disCount / 100))
        end
    end
    return cost
end

--设置自动花费有四卡才有
function CityModel:SetAutoSignCost(genre, flag)
    local card = genre or this:GetCardNumber()

    if flag then
        this:CalculatePlayCardBaseCost()
        --乘于系数得价格
        local cost = this:GetCostCoin(card)
        local four_card_auto = Csv.GetControlByName("four_card_auto_price")

        if four_card_auto ~= nil then
            cost = four_card_auto[1][1] * cost
        end
        this:SetCostCoin(card, cost)
    else
        this:CalculatePlayCardBaseCost()
    end
end

function CityModel:SetPowerupCost(gear, value)
    if powerupCost == nil then
        powerupCost = {}
    end
    if gear then
        powerupCost[gear] = value
    end
end

function CityModel:GetPowerupCost(gear)
    local geartype = gear or BuyPowerCardGenre.threegear
    if powerupCost and powerupCost[geartype] then
        return powerupCost[geartype]
    end
    return 0
end

---
---大厅界面选择的卡牌数量
---
function CityModel:SetCardNumber(number)
    cardNumber = number or 1
end

---
---大厅界面选择的卡牌数量
---
function CityModel:GetCardNumber()
    return cardNumber or 1
end

function CityModel:SetCityData(data)
    if data == nil then
        return
    end
    if cityResourceInfo == nil then
        cityResourceInfo = {}
    end
    self:UpdataTableData(cityResourceInfo, data)
end

function CityModel.S2C_SetRecommendplay(code, data)
    if code == RET.RET_SUCCESS then
        this:SetRecommendPlayData(data.info)
    end
end

function CityModel:SetRecommendPlayData(data)
    recommendPlay = data
    this:StartFullGameplayTimer()
end

function CityModel:SetrecGameResBaseUrl(data)
    recGameResBaseUrl = data
end

function CityModel:GetRecommendBanner()
    if not recommendPlay then
        return nil
    end

    local limitLevel = Csv.GetData("control", 157, "content")[1][1] or 2
    local playerLevel = ModelList.PlayerInfoModel:GetLevel()

    if playerLevel < limitLevel then
        return Csv.getSGPRecommd()
    end

    return recommendPlay.banner
end

function CityModel:GetRecommendBanners()
    return recommendPlay.banners
end

function CityModel:GetRecommendEntrance()
    return recommendPlay.entrance
end

function CityModel:GetRecommendUrl()
    if recommendPlay and recGameResBaseUrl then
        local recommdData = Csv.GetData("feature_enter", recommendPlay.recommend or ModelList.CityModel:GetRecommendid())
        local cityPlayId = nil
        if recommdData ~= nil and recommdData.city_play then
            cityPlayId = recommdData.city_play
        end

        return recGameResBaseUrl .. cityPlayId .. ".png"
    end
end

function CityModel:GetRecommendPop()
    if not recommendPlay then
        return nil
    end

    local limitLevel = Csv.GetData("control", 157, "content")[1][1] or 2
    local playerLevel = ModelList.PlayerInfoModel:GetLevel()

    if playerLevel < limitLevel then
        return Csv.getSGPPop()
    end

    return recommendPlay.pop
end

function CityModel:GetRecommendid()
    if not recommendPlay or not recommendPlay.recommend then
        local limitLevel = Csv.GetData("control", 157, "content")[1][1] or 2
        local playerLevel = ModelList.PlayerInfoModel:GetLevel()

        if playerLevel >= limitLevel then
            return Csv.getSGPRecommd()
        end
        return nil
    end
    return recommendPlay.recommend
end

function CityModel:GetRecommendModleList(id)
    if not recommendPlay or not recommendPlay.moduleList or #recommendPlay.moduleList == 0 then
        return nil
    end
    local value = 3
    for _, v in pairs(recommendPlay.moduleList) do
        if v.id == id then
            value = v.value
            break;
        end
    end
    return value
end

--- 返回推荐玩法的数据
function CityModel:GetRecommendModule()
    if not recommendPlay or not recommendPlay.moduleList or #recommendPlay.moduleList == 0 then
        return nil
    end

    for _, v in pairs(recommendPlay.moduleList) do
        if v.value == 2 then -- 2为推荐状态
            return v.id
        end
    end
    return nil
end

function CityModel:SetCityItemInfo(itemId, itemValue)
    ---该方法用于服务端返回出错错误码后把item数量归0，正常情况下不要调用该方法
    if cityResourceInfo then
        local city = self:GetCity()
        if cityResourceInfo[city] then
            local itemInfo = cityResourceInfo[city].itemInfo
            for key, value in pairs(itemInfo) do
                if value.id == itemId then
                    value.value = itemValue
                end
            end
        end
    end
end

function CityModel:SavePreviousPlayInfo()
    local gameMode                         = this:GetEnterGameMode()
    local cardNum                          = this:GetCardNumber()
    local betRate                          = this:GetBetRate()
    local powerupGear                      = this:GetPowerupGear()
    previous_play_info[tostring(gameMode)] = { cardNum = cardNum, betRate = betRate, powerupGear = powerupGear }
    fun.save_value("previous_play_info", previous_play_info)
end

function CityModel:GetPreviousPlayInfo(gameMode)
    gameMode = gameMode or this:GetEnterGameMode()
    local previous_play = previous_play_info

    if not previous_play or #previous_play == 0 then
        previous_play = fun.read_value("previous_play_info", previous_play_info)
    end

    return previous_play[tostring(gameMode)]
end

function CityModel:UpdataTableData(old_table, new_table, removeOld)
    assert(old_table ~= nil and new_table ~= nil, "old_table or new_table is nil")
    for key, value in pairs(new_table) do
        if type(value) == "table" then
            if value["id"] and value["value"] then
                local iscontain = false
                for key2, value2 in pairs(old_table) do
                    if value2["id"] == value["id"] then
                        value2["value"] = value["value"]
                        iscontain = true
                        break
                    end
                end
                if not iscontain then
                    table.insert(old_table, deep_copy(value))
                end
            elseif value["cityId"] then
                if old_table[value["cityId"]] == nil then
                    old_table[value["cityId"]] = deep_copy(value)
                else
                    self:UpdataTableData(old_table[value["cityId"]], value)
                end
            else
                if old_table[key] == nil or new_table[key]["puzzleItemId"] then
                    old_table[key] = deep_copy(value)
                else
                    self:UpdataTableData(old_table[key], value)
                end
            end
        else
            old_table[key] = deep_copy(value)
        end
    end
end

---
-----获取城市特有资源数量
---
function CityModel:GetCityResourceNum(resouceId, cityId)
    local city = cityId or self:GetCity()
    if city then
        if cityResourceInfo and cityResourceInfo[city] then
            local num = 0
            if cityResourceInfo[city].resourceInfo then
                for key, value in pairs(cityResourceInfo[city].resourceInfo) do
                    if value.id == resouceId then
                        num = num + value.value
                    end
                end
            end
            return num
        end
    end
    --log.r("Error:未有当前城市的resource信息，城市id：" .. city)
    return 0
end

---
-----获取城市特有物品数量
---
function CityModel:GetCityItemNum(itemId, cityId)
    local city = cityId or self:GetCity()
    if city then
        if cityResourceInfo and cityResourceInfo[city] then
            local num = 0
            if cityResourceInfo[city].itemInfo then
                for key, value in pairs(cityResourceInfo[city].itemInfo) do
                    if value.id == itemId then
                        num = num + value.value
                    end
                end
            end
            return num
        end
    end
    --log.r("Error:未有当前城市的itemId信息，城市id：" .. city)
    return 0
end

---
-----获取城市 美食袋子
---
function CityModel:GetCityFoodBag(cityId)
    local FoodBags = {}
    --local city = cityId or self:GetCity()
    local playId = self.GetPlayIdByCity()
    local city = Csv.GetData("city_play", playId, "city_id")
    if cityResourceInfo and cityResourceInfo[city] then
        if cityResourceInfo[city].itemInfo then
            for key, value in pairs(cityResourceInfo[city].itemInfo) do
                if Csv.GetData("item", value.id, "result")[1] == 6 then
                    table.insert(FoodBags, deep_copy(value))
                end
            end
        end
    end
    return FoodBags
end

---
---获取当前城市菜品的收集进度
---
function CityModel:GetCityRecipe(cityId)
    local city = cityId or self:GetCity()
    if cityResourceInfo and cityResourceInfo[city] then
        return tonumber(cityResourceInfo[city].cityRecipe)
    end
    --未有当前城市的收集信息，城市id：" .. city)
    return 0
end

---
---设置当前城市菜品的收集进度（中途解锁菜品服务器不会更新过来，需要主动变更）
---
function CityModel:SetCityRecipe(recipe, cityId)
    local city = cityId or self:GetCity()
    if cityResourceInfo and cityResourceInfo[city] then
        if recipe > tonumber(cityResourceInfo[city].cityRecipe) then
            cityResourceInfo[city].cityRecipe = recipe
        end
    else
        --log.r("Error:未有当前城市的收集信息，城市id：" .. city)
    end
end

---
-----获取城市等级
---
function CityModel:GetCityLevel(cityId)
    local city = cityId or self:GetCity()
    if cityResourceInfo and cityResourceInfo[city] then
        return cityResourceInfo[city].cityLevel
    end
    --log.r("Error:未有当前城市的等级信息，城市id：" .. city)
    return 0
end

---
-----获取城市经验
---
function CityModel:GetCityExp(cityId, gameMode)
    local city = cityId or self:GetCity(gameMode)
    if cityResourceInfo and cityResourceInfo[city] then
        return cityResourceInfo[city].cityLevelExp
    end
    --log.r("Error:未有当前城市的经验信息，城市id：" .. city)
    return 0
end

function CityModel:IsCuisineReward(cityId, gameMode)
    return 100 == this:GetCityExp(cityId, gameMode)
end

---获取城市拼图碎片数据
function CityModel:GetCityPuzzleData(cityId, gameMode)
    local city = cityId or self:GetCity()
    --local gameMode = gameMode or this:GetEnterGameMode()
    if cityResourceInfo and cityResourceInfo[city] then
        return cityResourceInfo[city].puzzleState
    end
end

function CityModel:GetEnterGameMode()
    local playid = this.GetPlayIdByCity()
    local playType = Csv.GetData("new_city_play", playid, "play_type")
    return playType
end

function CityModel:GetCardsCurrentPage(level)
    local page = self:GetPage()
    local playId = self.GetPlayIdByCity()
    local level = level or currentPowerLevel
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    if powerCardList[playId] and powerCardList[playId][cardNum] and powerCardList[playId][cardNum][level] and powerCardList[playId][cardNum][level][page] then
        return powerCardList[playId][cardNum][level][page]["powerups"]
    end
    return {}
end

function CityModel:GetJokeCardsCurrentPage(level)
    local page = self:GetPage()
    local playId = self.GetPlayIdByCity()
    local level = level or currentPowerLevel
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    if powerCardList[playId] and powerCardList[playId][cardNum] and powerCardList[playId][cardNum][level] and powerCardList[playId][cardNum][level][page] then
        return powerCardList[playId][cardNum][level][page]["jokerPowerups"]
    end
    return {}
end

function CityModel:GetCardsGroupId(page, level)
    local curPage = page or self:GetPage()
    local playId = self.GetPlayIdByCity()
    local level = level or 0
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    if powerCardList[playId] and powerCardList[playId][cardNum] and powerCardList[playId][cardNum][level] and powerCardList[playId][cardNum][level][curPage] then
        return powerCardList[playId][cardNum][level][curPage]["groupId"]
    end
end

function CityModel:GetCardsLevel(page, level)
    local curPage = page or self:GetPage()
    local playId = self.GetPlayIdByCity()
    local level = level or currentPowerLevel
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    if powerCardList[playId] and powerCardList[playId][cardNum] and powerCardList[playId][cardNum][level] and powerCardList[playId][cardNum][level][curPage] then
        return powerCardList[playId][cardNum][level][curPage]["level"]
    end
end

function CityModel:GetCardsPower(page, level)
    local curPage = page or self:GetPage()
    local playId = self.GetPlayIdByCity()
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    level = level or currentPowerLevel
    if powerCardList[playId] and powerCardList[playId][cardNum] and powerCardList[playId][cardNum][level] and powerCardList[playId][cardNum][level][curPage] then
        return powerCardList[playId][cardNum][level][curPage]["power"]
    end
end

---当前城市是否有已购买的powerup卡片
function CityModel:IsPowerCardEmpty(level)
    local playId = self.GetPlayIdByCity()
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    return powerCardList[playId] == nil or powerCardList[playId][cardNum] == nil or
    powerCardList[playId][cardNum][level] == nil or powerCardList[playId][cardNum][level][1] == nil
end

function CityModel:GetCardsPreviousPage(level)
    local playId = self.GetPlayIdByCity()
    local level = level or currentPowerLevel
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    if not powerCardPage[playId] then
        powerCardPage[playId] = {}
        powerCardPage[playId][cardNum] = {}
    end

    powerCardPage[playId][cardNum][level] = math.max((powerCardPage[playId][cardNum][level] or 1) - 1, 1)
    return self:GetCardsCurrentPage(level)
end

function CityModel:GetCardsNextPage(level)
    local playId = self.GetPlayIdByCity()
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    if not powerCardList[playId] then
        powerCardList[playId] = {}
        powerCardList[playId][cardNum] = {}
        powerCardList[playId][cardNum][level] = {}
    end

    if not powerCardList[playId][cardNum] then
        powerCardList[playId][cardNum] = {}
        powerCardList[playId][cardNum][level] = {}
    end

    if not powerCardList[playId][cardNum][level] then
        powerCardList[playId][cardNum][level] = {}
    end

    local temCardList = powerCardList[playId][cardNum][level] or {}
    powerCardPage[playId][cardNum][level] = math.min((powerCardPage[playId][cardNum][level] or 1) + 1,
        fun.get_table_size(temCardList))
    return self:GetCardsCurrentPage(level)
end

function CityModel:GetCardsMaxPage(level)
    local playId = self.GetPlayIdByCity()
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    if not powerCardList[playId] then
        powerCardList[playId] = {}
        powerCardList[playId][cardNum] = {}
        powerCardList[playId][cardNum][level] = {}
    end

    if not powerCardList[playId][cardNum] then
        powerCardList[playId][cardNum] = {}
        powerCardList[playId][cardNum][level] = {}
    end

    if not powerCardList[playId][cardNum][level] then
        powerCardList[playId][cardNum][level] = {}
    end

    if not powerCardPage[playId] then
        powerCardPage[playId] = {}
        powerCardPage[playId][cardNum] = {}
    end

    local temCardList = powerCardList[playId][cardNum][level] or {}
    powerCardPage[playId][cardNum][level] = fun.get_table_size(temCardList)
    return self:GetCardsCurrentPage(level)
end

---
---获取powerup卡片的当前页数
---
function CityModel:GetPage(level)
    local playId = self.GetPlayIdByCity()
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0

    if not powerCardPage[playId] then
        powerCardPage[playId] = {}
        powerCardPage[playId][cardNum] = {}
    end

    if not powerCardPage[playId][cardNum] then
        powerCardPage[playId][cardNum] = {}
    end

    if not level then
        level = currentPowerLevel
    end

    return powerCardPage[playId][cardNum][level] or 1
end

function CityModel:ResetPage(level)
    local playId = self.GetPlayIdByCity()
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    if not level then
        level = currentPowerLevel
    end

    if not powerCardPage[playId] then
        powerCardPage[playId] = {}
        powerCardPage[playId][cardNum] = {}
    end

    if not powerCardPage[playId][cardNum] then
        powerCardPage[playId][cardNum] = {}
    end

    powerCardPage[playId][cardNum][level] = 1
end

---
---获取powerup卡片的最大页数
---
function CityModel:GetMaxPage(level)
    local playId = self.GetPlayIdByCity()
    local flag = ModelList.PlayerInfoModel:CheckAbTest("powerup_range") -- ab测试
    local cardNum = flag and this:GetCardNumber() or 0
    if not level then
        level = currentPowerLevel
    end

    if not powerCardList[playId] then
        powerCardList[playId] = {}
        powerCardList[playId][cardNum] = {}
        powerCardList[playId][cardNum][level] = {}
    end

    if not powerCardList[playId][cardNum] then
        powerCardList[playId][cardNum] = {}
        powerCardList[playId][cardNum][level] = {}
    end

    if not powerCardList[playId][cardNum][level] then
        powerCardList[playId][cardNum][level] = {}
    end

    local temCardList = powerCardList[playId][cardNum][level] or {}
    local page = fun.get_table_size(temCardList)
    if page > 0 then
        return page
    end

    return 0
end

function CityModel.C2S_ChangeCity(cityId)
    log.r("[CityModel] ChangeCity, curCityId:", curCityId)
    log.r("[CityModel] ChangeCity, cityId:", cityId)
    curCityId = cityId or curCityId --math.min(maxCity,math.max(1,cityId))
end

function CityModel.SetHomeCity(cityid)
    temCityId = cityid
end

function CityModel.GetHomeCity()
    return temCityId
end

function CityModel.GetDownloadList()
    return DownloadManagerList or {}
end

function CityModel.SetDownloadList(machineID, flag)
    if not DownloadManagerList then
        DownloadManagerList = {}
    end
    DownloadManagerList[machineID] = flag
end

--[[
function CityModel.S2C_ChangeCity(code,data)
    if code == RET.RET_SUCCESS then
        --log.r("=============================>>change city " .. tostring(data.city) .." id = " .. temCityId)
        if data.city then
            curCityId = temCityId
        end
    else

    end
end
--]]

function CityModel.C2S_BuyPowerUpCards(powerupType, coupon, couponUseId, level, cardNum)
    --Http.req_buy_powerup(powerupType,enterGameMode,this.GetCity())
    this.SendMessage(MSG_ID.MSG_BUY_POWERUP, {
        rate = powerupType,
        type = this:GetEnterGameMode(),
        cityId = this.GetCity(),
        couponId = coupon,
        useCouponId = couponUseId,
        playId = this.GetPlayIdByCity(),
        puLevel = level,
        betRate = this:GetBetRate(),
        cardNum = cardNum
    })
    UISound.play("powerup_pay")
end

function CityModel.S2C_BuyPowerUpCards(code, data)
    if code == RET.RET_SUCCESS and data then
        local playId = data.playId or this.GetPlayIdByCity()
        local levelId = data.puLevel or currentPowerLevel
        local cardNum = data.cardNum
        if powerCardList[playId] == nil then
            powerCardList[playId] = {}
            powerCardList[playId][cardNum] = {}
            powerCardList[playId][cardNum][levelId] = {}
        end

        if not powerCardList[playId][cardNum] then
            powerCardList[playId][cardNum] = {}
            powerCardList[playId][cardNum][levelId] = {}
        end

        if not powerCardList[playId][cardNum][levelId] then
            powerCardList[playId][cardNum][levelId] = {}
        end

        table.insert(powerCardList[playId][cardNum][levelId], deep_copy(data))
        this.SendNotification(NotifyName.PowerUps.Buy_PowerUp_Result)
    else
        --        Facade.SendNotification(NotifyName.Common.CommonTip,"购买失败")
        --Facade.SendNotification(NotifyName.Common.PopupDialog, 8009, 1);
        UIUtil.show_common_popup(8009, true)
    end
end

function CityModel.C2S_FetchPowerUp(scenes, level)
    --Http.req_fetch_powerup()
    if not scenes then scenes = 1 end
    if not level then
        level = 0
    else
        currentPowerLevel = level
    end

    -- this.SendMessage(MSG_ID.MSG_GET_POWERUP,{uidId = powerupCardId or "",scenes = scenes,level = level},true) --玩家没有powerup卡时服务器不返回消息的
    this.SendMessage(MSG_ID.MSG_GET_POWERUP, { uidId = powerupCardId or "", scenes = scenes }, true)
end

---登录请求的接口
function CityModel.Login_C2S_FetchPowerUp(scenes, level)
    if not scenes then scenes = 1 end
    if not level then
        level = 0
    else
        currentPowerLevel = level
    end
    return MSG_ID.MSG_GET_POWERUP,
        Base64.encode(Proto.encode(MSG_ID.MSG_GET_POWERUP, { uidId = powerupCardId or "", scenes = scenes }))
end

function CityModel.S2C_FetchPowerUp(code, data)
    if code == RET.RET_SUCCESS and data ~= nil then
        --附带其它-推送协议
        table.each(data.nextMessages, function (v)
            local body = Base64.decode(v.msgBase64)
            local ret = Proto.decode(v.msgId, body)
            Message.DispatchMessage(v.msgId, v.code, ret)
        end)

        if data.unfit then
            if data.powerups then
                powerupCardId = data.uidId

                powerCardList = {}
                for _, value in pairs(data.powerups) do
                    local playId = value.playId or this.GetPlayIdByCity()
                    local level = value.puLevel
                    local cardNum = value.cardNum
                    if powerCardList[playId] == nil then
                        powerCardList[playId] = {}
                        powerCardList[playId][cardNum] = {}
                        powerCardList[playId][cardNum][level] = {}
                    end

                    if powerCardList[playId][cardNum] == nil then
                        powerCardList[playId][cardNum] = {}
                        powerCardList[playId][cardNum][level] = {}
                    end

                    if not powerCardList[playId][cardNum][level] then
                        powerCardList[playId][cardNum][level] = {}
                    end

                    local powercard         = {} --要跟登录时的数据结构一致
                    powercard.powerups      = {}
                    powercard.jokerPowerups = {}
                    powercard.id            = value.id
                    powercard.groupId       = value.groupId
                    powercard.pulevel       = level
                    powercard.cardNum       = value.cardNum

                    for k, v in pairs(value.powerUp) do
                        if v then
                            table.insert(powercard.powerups, v)
                        end
                    end
                    if value.jokerPowerups then
                        for k, v in pairs(value.jokerPowerups) do
                            if v then
                                table.insert(powercard.jokerPowerups, v)
                            end
                        end
                    end

                    table.insert(powerCardList[playId][cardNum][level], powercard)
                end
            end
        end

        if data.seasonPu then
            this.puBuffSeasonId = data.seasonPu.seasonId
            this.puBuffSeasonEndTime = data.seasonPu.seasonEndTime
            log.log("CityModel.S2C_FetchPowerUp, seasonId, seasonEndTime 1 ", data.seasonPu)
        else
            this.puBuffSeasonId = data.seasonId
            this.puBuffSeasonEndTime = data.seasonEndTime
            log.log("CityModel.S2C_FetchPowerUp, seasonId, seasonEndTime 2 ", data.seasonId, data.seasonEndTime)
        end
    else
        log.log("CityModel.S2C_FetchPowerUp error", code, data)
    end

    --只有是界面上查询得才可以进行界面通知
    if data == nil or (data ~= nil and data.scenes and data.scenes == 0) then
        Facade.SendNotification(NotifyName.PowerUps.FetchPowerUp_Result)
    end

    Facade.SendNotification(NotifyName.PowerUps.FetchPowerUp_Result2)
end

--获取所有城市经验
function CityModel:GetAllCityExp()
    local ret = {}
    --log.r("cityResourceInfo "..#cityResourceInfo)
    for k, v in pairs(cityResourceInfo) do
        ret[k] = this:GetCityExp(k)
    end
    return ret
end

local foodBagIds = {
    1201,
    1202,
    1203,
    1204,
    1205,
    1206,
    1207,
    1208,
    1209,
    1210,
}
function CityModel:GetCityBox()
    local city = self:GetCity()
    return self:GetCityItemNum(foodBagIds[city], city)
end

function CityModel:GetCityBoxItemId()
    local city = self:GetCity()
    return foodBagIds[city]
end

function CityModel:C2S_OpenBox(itemIdList, type, playType)
    --Http.req_fetch_powerup()

    this.SendMessage(MSG_ID.MSG_OPEN_BOX, {
        itemIds = itemIdList,
        cityId = self:GetCity(),
        type = type,
        playType = playType,
        playId = ModelList.CityModel.GetPlayIdByCity()
    })                                                                                                          --玩家没有powerup卡时服务器不返回消息的
end

function CityModel.S2C_OpenBox(code, data)
    if code == RET.RET_SUCCESS then
        Event.Brocast(EventName.Event_show_treasure_box_refresh, data)
    else
        --Facade.SendNotification(NotifyName.HideUI,ViewList.FoodBagClaimView)
    end
end

--美食界面领取城市等级奖励
function CityModel.C2S_ClaimCityLevelReward(cityId, playType)
    this.SendMessage(MSG_ID.MSG_CITYLEVEL_REWARD, { cityId = cityId, playType = playType })
end

--返回美食界面领取城市等级奖励
function CityModel.S2C_ClaimCityLevelReward(code, data)
    --错误码不为0也发消息，避免卡死
    Facade.SendNotification(NotifyName.FoodIngredientView.ClaimCityLevelRewardResult,
        (data and { data.result or code } or { code })[1])
end

function CityModel.haveisTraSGP()
    if not isTraSGP then
        return true
    end
    return false
end

function CityModel.setTrasSgp()
    isTraSGP = true
end

function CityModel.checkModuleDownload(newCity)
    --如果没有的话，去读取默认的模板
    local MachineItemData = nil
    local Macheindata = deep_copy(MachinePortalManager.get_portal_data_by_machine())

    local loadDefault = 2    --已下载
    --and fun.IsEditor() == false
    if Macheindata and type(Macheindata) == "table" then
        for _, v in pairs(Macheindata) do
            if v.moduleType == modular_type.cityType and newCity == v.cityId then
                MachineItemData = deep_copy(v)
                break;
            end
        end

        if not MachineItemData then
            log.r("MachineItemData ,not data ")

            --有bug
        else
            local version = MachineDownloadManager.read_machine_local_version(MachineItemData.machine_id)
            if version ~= nil then                             --也有可能正在下载
                if version >= MachineItemData.version then     --已下载
                    --TODO by LwangZg 运行时热更部分
                    if resMgr then
                        resMgr:RefreshModuleInfo(MachineItemData.name)
                    end
                    loadDefault = 2
                else
                    if MachineDownloadManager.is_machine_downloading(MachineItemData.machine_id) then
                        loadDefault = 1   --下载中
                    else
                        loadDefault = 0
                    end
                end
            else
                log.r("  error   error  error  error  error  error status not Download ")
            end
        end
    end

    return loadDefault, MachineItemData
end

------------额外奖励------------------
function CityModel.isOpenExtra(bet)
    return Csv.getCityOpenExtra(curCityId, bet)
end

-------------------------添一个flag来告知进入战斗大厅时是否强制开到最大下注bet-------------------------begin
function CityModel:SetForceMaxBet()
    self.forceMaxBet = true
end

function CityModel:IsForceMaxBet()
    return self.forceMaxBet
end

function CityModel:ClearForceMaxBet()
    self.forceMaxBet = nil
end

-------------------------添一个flag来告知进入战斗大厅时是否强制开到最大下注bet-------------------------end
--当前玩法是否参与赛季PU
function CityModel:CanCurPlayUsePuBuff()
    local curPlayId = self.GetPlayIdByCity()
    if not curPlayId then
        log.log("CityModel:CanCurPlayUsePuBuff F cur play id is nil")
        return false
    end

    local info = Csv.GetData("city_play", curPlayId)
    if not info then
        log.log("CityModel:CanCurPlayUsePuBuff F no info in city_play", curPlayId)
        return false
    end

    local allowPlayTypeList = { 1, 2, 18 }
    if IsValueInList(info.play_type, allowPlayTypeList) then
        log.log("CityModel:CanCurPlayUsePuBuff T", info.play_type)
        return true
    else
        log.log("CityModel:CanCurPlayUsePuBuff F invalid play type ", info.play_type)
        return false
    end
end

--获得当前所在赛季pu的赛季id
function CityModel:GetPuBuffSeasonId()
    log.log("CityModel:GetPuBuffSeasonId default 0", self.puBuffSeasonId)
    return self.puBuffSeasonId or 0
end

--获得当前所在赛季pu的赛季结止时间点
function CityModel:GetPuBuffSeasonEndTime()
    log.log("CityModel:GetPuBuffSeasonEndTime default 0", self.puBuffSeasonEndTime)
    return self.puBuffSeasonEndTime or 0
end

--获得当前所在赛季pu的赛季剩余时长
function CityModel:GetPuBuffSeasonRemainTime()
    local remainTime = self:GetPuBuffSeasonEndTime() - ModelList.PlayerInfoModel.get_cur_server_time()
    if remainTime < 0 then
        log.log("CityModel:GetPuBuffSeasonRemainTime less than 0")
        return 0
    else
        log.log("CityModel:GetPuBuffSeasonRemainTime ", remainTime)
        return remainTime
    end
end

--当前是否在某赛季的时间范围内
function CityModel:IsPuBuffSeasonValid()
    if self:GetPuBuffSeasonId() > 0 and self:GetPuBuffSeasonRemainTime() > 0 then
        log.log("CityModel:IsPuBuffSeasonValid T")
        return true
    else
        log.log("CityModel:IsPuBuffSeasonValid F")
        return false
    end
end

--获得pu buff的剩余时长
function CityModel:GetPuBuffRemainTime()
    local itemId = Resource.puBuff                                           --39
    local expireTime = ModelList.ItemModel.getResourceNumByType(itemId) or 0 --截止时间戳
    local remainTime = expireTime - ModelList.PlayerInfoModel.get_cur_server_time()
    log.log("CityModel:GetPuBuffRemainTime expireTime, remainTime is ", expireTime, remainTime)
    return remainTime
end

function CityModel:GetPuBuffCardId()
    local seasonId = self:GetPuBuffSeasonId()
    local cardId = Csv.GetData("powerup_card_season", seasonId, "powerup_card_id")
    if not cardId then
        log.log("CityModel:GetPuBuffCardId no data seasonId is ", seasonId)
    end
    log.log("CityModel:GetPuBuffCardId cardId is ", cardId)
    return cardId
end

function CityModel:SavePuBuffStateRecord(buffExpireTime)
    local remainTime = buffExpireTime - ModelList.PlayerInfoModel.get_cur_server_time()
    log.log("CityModel:SavePuBuffStateRecord remainTime ", remainTime)
    if remainTime > 0 then
        self:SetPuBuffStateRecord(true)
    else
        self:SetPuBuffStateRecord(false)
    end
end

function CityModel:SetPuBuffStateRecord(state)
    local playerInfo = ModelList.PlayerInfoModel:GetUserInfo()
    if self:GetPuBuffStateRecord() then
        if not state then --1->0
            fun.save_value("SEASON_PU_BUFF_STATE" .. playerInfo.uid, 0)
            log.log("CityModel:SetPuBuffStateRecord 1->0 ")
            --还有些情况未处理到
            if self:IsPuBuffSeasonValid() then
                log.log("CityModel:SetPuBuffStateRecord 1->0 并记录 可以弹提示")
                self:RecordIsNeepPopupBuffPurchaseTipState(true)
            end
        else
            log.log("CityModel:SetPuBuffStateRecord 1->1 ")
        end
    else
        if state then --0->1
            self:RecordIsNeepPopupBuffPurchaseTipState(false)
            fun.save_value("SEASON_PU_BUFF_STATE" .. playerInfo.uid, 1)
            log.log("CityModel:SetPuBuffStateRecord 0->1 ")
        else
            log.log("CityModel:SetPuBuffStateRecord 0->0 ")
        end
    end
end

function CityModel:GetPuBuffStateRecord()
    local playerInfo = ModelList.PlayerInfoModel:GetUserInfo()
    local stateCode = fun.read_value("SEASON_PU_BUFF_STATE" .. playerInfo.uid, 0)
    log.log("CityModel:GetPuBuffStateRecord stateCode ", stateCode)
    return stateCode == 1
end

function CityModel:RecordIsNeepPopupBuffPurchaseTipState(state)
    log.log("CityModel:RecordIsNeepPopupBuffPurchaseTipState state ", state)
    local playerInfo = ModelList.PlayerInfoModel:GetUserInfo()
    if state then
        fun.save_value("SEASON_PU_BUFF_POPUP_PURCHASE_TIP_STATE" .. playerInfo.uid, 1)
    else
        fun.save_value("SEASON_PU_BUFF_POPUP_PURCHASE_TIP_STATE" .. playerInfo.uid, 0)
    end
end

function CityModel:GetIsNeepPopupBuffPurchaseTipState()
    local playerInfo = ModelList.PlayerInfoModel:GetUserInfo()
    local stateCode = fun.read_value("SEASON_PU_BUFF_POPUP_PURCHASE_TIP_STATE" .. playerInfo.uid, 0)
    log.log("CityModel:GetIsNeepPopupBuffPurchaseTipState stateCode ", stateCode)
    return stateCode == 1
end

--机台全开活动是否开启
function CityModel:IsFullGameplayOpen()
    if recommendPlay then
        local count = GetTableLength(recommendPlay.entrance)
        if count >= 4 then
            return true
        end
    end
end

--机台全开活动结束时间
function CityModel:GetFullGameplayEndTime()
    if not this:IsFullGameplayOpen() then
        return
    end

    return recommendPlay.endTime
end

--机台全开活动剩余时间
function CityModel:GetFullGameplayRemainTime()
    if not this:IsFullGameplayOpen() then
        return 0
    end

    local count = GetTableLength(recommendPlay.entrance)
    if count >= 4 then
        --推荐机台数量大于4，可以认为活动已开启
        if recommendPlay.endTime then
            local curTime = ModelList.PlayerInfoModel.get_cur_server_time()
            local remain = recommendPlay.endTime - curTime
            return remain
        end
    end
    
    return 0
end

--机台全开活动计时器
function CityModel:StartFullGameplayTimer()
    if this.fullGameplayTimer then
        this.fullGameplayTimer:Stop()
        this.fullGameplayTimer = nil
    end
    
    if recommendPlay and recommendPlay.endTime then
        this.fullGameplayTimer = Timer.New(function()
            if recommendPlay and recommendPlay.endTime then
                local curServerTime = ModelList.PlayerInfoModel.get_cur_server_time()
                if curServerTime >= recommendPlay.endTime then
                    log.log("[FullGameplay] activity time over.")
                    this.fullGameplayTimer:Stop()
                    Event.Brocast(NotifyName.FullGameplay.ActivityEnd)
                end
            else
                log.log("[FullGameplay] activity not valid when timer running, recommendPlay data error :", recommendPlay)
            end
        end, 1, -1)
        this.fullGameplayTimer:Start()
    end
end

---是调试玩家的处理逻辑
function CityModel:CheckDebugPlayer(debugLevel)
    if debugLevel and debugLevel > 0 then
        log.enabled = true
        if (not AppConst.IsDevMode()) then
            Cache.load_prefabs(AssetList["Reporter"], "Reporter", function(prefab)
                if prefab then
                    local obj = fun.get_instance(prefab)
                    if obj then
                        local mana = UnityEngine.GameObject.Find("GameManager")
                        fun.set_parent(obj,mana)
                    end
                end
            end)
        end
    end
end

this.MsgIdList =
{
    --{msgid = MSG_ID.MSG_USER_CITY, func = this.S2C_ChangeCity},
    {msgid = MSG_ID.MSG_BUY_POWERUP,func = this.S2C_BuyPowerUpCards},
    --{msgid = MSG_ID.MSG_GAME_LOAD, func = this.S2C_EnterGame},
    {msgid = MSG_ID.MSG_GET_POWERUP, func = this.S2C_FetchPowerUp},
    {msgid = MSG_ID.MSG_OPEN_BOX, func = this.S2C_OpenBox},
    {msgid = MSG_ID.MSG_CITYLEVEL_REWARD, func = this.S2C_ClaimCityLevelReward},
    {msgid = MSG_ID.MSG_RECOMMEND_PLAY,func = this.S2C_SetRecommendplay},
}

return this
