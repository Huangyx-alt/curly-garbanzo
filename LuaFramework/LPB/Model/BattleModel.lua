---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2021/11/22 10:55
---
require 'Model/BaseModel'
require 'Model/ModelPart/UploadBattleData'

local BattleModel = BaseModel:New("BattleModel")
local this = BattleModel

this.game_type = PLAY_TYPE.PLAY_TYPE_NULL
this.city_play_id = 0
this.four_card_auto = false  -- 4卡自动盖章

---  data -----
---3,4 卡自动盖章，从control表获取配置
this.Is_Open_Auto_BackCard_Click = false
--- 战斗中食物双倍
this.Is_Battle_Double_Food_State = false
--- 战斗中拼图双倍
this.Is_Battle_Double_Puzzle_State = false
--- 战斗中饼干双倍
this.Is_Battle_Double_Cookie_State = false
--- 战斗中是否有杯赛
this.Is_Battle_Competition = false
--- 战斗中是否有SuperMatch活动
this.Is_Battle_SuperMatch = false

----
---是否自动盖章
this.isAutoSign = false
--- 是否小丑机台
this.isJokerMachine = false
--- 是否有小丑喷球器
this.hasBallSprayer = false
--- 是否主动退出战斗
this.isQuitBattle = false

function BattleModel:InitData()
    this:Register()
    ----判断是否默认开启自动盖章

    --local four_card_auto = Csv.GetData("control", 103, "content")
    --if four_card_auto ~= nil then
    --   if four_card_auto[1][1] == 1 then
    --       this.isAutoSign = true
    --   else
           this.isAutoSign = false
       --end
    --end

    self.boxItemID = nil
end

function BattleModel:CancelInitData()
    this:UnRegister()
end

---正在火箭界面
function BattleModel:IsRocket()
    local a,b = math.modf(this.game_state/GameState.Rocket)
    return (a == 1 and b< 1 ) and true  or false
end

function BattleModel:SetGameState(state)
    this.game_state = state
end

function BattleModel:GetGameState()
    return this.game_state
end


--是否是挂机
function BattleModel:IsHangUp()
    return this.game_type == PLAY_TYPE.PLAY_TYPE_AUTO_TICKET
end


--获取逻辑准备状态，数据收集完成就可以展开游戏
function BattleModel:IsReadyEnterScene()
    if not ModelList.BattleModel:GetCurrModel() then
        return false
    end
    return ModelList.BattleModel:GetCurrModel():IsReadyEnterScene()
end


function BattleModel:IsGameing()
    if this:GetCurrModel() then
        return this:GetCurrModel():IsGameing()
    end
    return false
end

--是否有卡牌切换功能
function BattleModel:IsNeedCardSwitch()
    if this.game_type ~= PLAY_TYPE.PLAY_TYPE_AUTO_TICKET and  #ModelList.GameModel:GetCards() > 2 then
        return true
    end
    return false
end

-- 有可以被点击的格子，在视野外
function BattleModel:CanSignCellInBackground(cardid)
    --if this.game_type ~= PLAY_TYPE.PLAY_TYPE_AUTO_TICKET and  #ModelList.GameModel:GetCards() > 2 then
    --    --cardid = tonumber(cardid)
    --    return not this:GetCurrBattleView():IsCardShowing(cardid)
    --end
    return true
end

function BattleModel:IsGameSettling()
    return this:GetCurrModel():IsGameSettling()
end



-- 遍历数组
function BattleModel:IsInTable(value, tbl)
    for k, v in pairs(tbl) do
        if v == value then
            return true;
        end
    end
    return false;
end

-- 查看某值是否为表tbl中的key值
function BattleModel:keyIn(tbl, key)
    if tbl == nil then
        return false
    end
    for k, v in pairs(tbl) do
        if k == key then
            return true
        end
    end
    return false
end


--- 以city_play表的id设置游戏类型
function BattleModel:SetGameType(playId)
    --if playId == 1 then
    --    local city = ModelList.CityModel:GetCity()
    --    this.city_play_id = playId
    --    for _,v in pairs(Csv.new_city_play) do
    --        if v.city_id == city and  v.play_type == playId then
    --            this.city_play_id  = v.id
    --            break
    --        end
    --    end
    --else
        this.city_play_id = playId
    --end
    
    local curr_game_type = Csv.GetData("new_city_play",playId,"play_type")
    this.game_type = curr_game_type
    this.GetModelByPlayID(playId):SetSelfGameType(curr_game_type)
    this.SetIsJokerMachine(false)
    this.SetHasJokerBallSprayer(false)
    this.SetQuitBattle(false)
end

--- 直接设置游戏类型
function BattleModel:DirectSetGameType(curr_game_type, playId)
    this.game_type = curr_game_type
    if playId then
        this.city_play_id = playId
    end
    this.GetModelByPlayID(playId):SetSelfGameType(curr_game_type)
end

--游戏类型
function BattleModel:GetGameType()
    return this.game_type
end


--游戏类型
function BattleModel:GetGameCityPlayID()
    return this.city_play_id
end

--游戏类型
function BattleModel:GetGameTypeName()
    return Csv.GetData("new_game_mode",this.city_play_id,"type_name")
end

function BattleModel:Clear()
    this.game_state = GameState.Ready
    this.game_type = PLAY_TYPE.PLAY_TYPE_NULL
end

--- @return BaseGameModel
function BattleModel:GetCurrModel()
    if this.city_play_id == 0 then return ModelList.GameModel end
    local modelName = Csv.GetData("new_game_mode",this.city_play_id,"model")
    return ModelList[modelName]
end

function BattleModel:GetPartName(key)
    return Csv.GetData("new_game_mode",this.city_play_id,key)
end

function BattleModel:GetCurrBattleView()
    local viewName = Csv.GetData("new_game_mode",this.city_play_id,"view")
    return ViewList[viewName]
end

function BattleModel:BackToHallScene()
    this:GetCurrModel():Clear()
    LoadScene("SceneHome",ViewList.SceneLoadingHomeView,true)
end

function BattleModel.QuitBattle()
    --resMgr:UnloadLobbyBundle()
    ----UnityEngine.Resources.UnloadUnusedAssets()
    if this:GetCurrModel() then
        this:GetCurrModel():Clear()
    end
    ModelList.BattleModel:SetShowDetail(false)
    ModelList.GuideModel:Reset()
    UISound.stop_bgm()
    require("Combat.Machine.BattleMachineList")
    BattleMachineList:StopBattleGMMachine()
    BattleMachineList:StopBattleMachine()
    require("View.Bingo.BattleModuleList")
    BattleModuleList:UnLoadCardModule()
    if BattleLogic then
        BattleLogic.UnLoadBingoLogic()
    end
    require("Combat.GlobalBattleMachineList")
    GlobalBattleMachineList:StopBattleGlobalMachine()
    LuaTimer:Clear(LuaTimer.TimerType.Battle)
    LuaTimer:Clear(LuaTimer.TimerType.BattleUI)
    this.SetBattleDouble(nil)
    this.SetIsJokerMachine(false)
    this.SetQuitBattle(false)

    if ViewList.SGSuperMatchMainView then
        Facade.SendNotification(NotifyName.CloseUI,ViewList.SGSuperMatchMainView)
        ViewList.SGSuperMatchMainView = nil
    end
end

function BattleModel:PauseBattle(isPause)
    if this:GetCurrModel() then
    this:GetCurrModel().PauseBattleMachine(isPause)
    end
    if not isPause then
        Facade.SendNotification(NotifyName.HideUI,ViewList.BattleReconnectView)
    end
end



function BattleModel:UploadGameData(data)
    return UploadBattleData:PackFinalCardInfo(data)
end

function BattleModel:Register()
    Event.AddListener(Notes.QUIT_BATTLE, self.QuitBattle)
    Event.AddListener(EventName.Pause_Battle, self.PauseBattle)
end


function BattleModel:UnRegister()
    Event.RemoveListener(Notes.QUIT_BATTLE, self.QuitBattle)
    Event.RemoveListener(EventName.Pause_Battle, self.PauseBattle)
end

function BattleModel.ResGameException(code,data)
    if data then
        if data.code == RET.RET_GAME_OVERED then
            SDK.upload_settle_data("game_exception_game_overed")
            this:GetCurrModel().ReqFetchSettle()
        elseif data.code == RET.RET_GAME_NOT_EXIST then
            SDK.upload_settle_data("game_exception_no_game")
            UIUtil.return_to_scenehome()
            UIUtil.show_common_global_popup(8004,true)
            log.r("error  :  RET_GAME_NOT_EXIST  游戏不存在")
        elseif data.code == RET.RET_SYSTEM_MAINTAIN then
            --SDK.upload_settle_data("game_exception_no_game")
            --UIUtil.return_to_scenehome()
            UIUtil.show_common_global_popup(993,true)
        else
            UIUtil.return_to_scenehome()
            UIUtil.show_common_global_popup(8004,true)
            SDK.upload_settle_data("game_exception_other")
        end
    end
end

function BattleModel.ResFetchSettleData(code,data)
    if code == RET.RET_SUCCESS then
        -- if this:GetGameType() ~= PLAY_TYPE.PLAY_TYPE_AUTO_TICKET then
        --     Message.DispatchMessage(MSG_ID.MSG_GAME_COMMON_SETTLE,0,data)
        -- else
        --     Message.DispatchMessage(MSG_ID.MSG_HANGUP_SETTLE,0,data)
        -- end
            
        --如果收到零，那就是没有收到预结算，指定出问题了
        if data.settled == 0 then 
            
        end

        --附带其它-推送协议
        table.each(data and data.nextMessages, function(v)
            local body = Base64.decode(v.msgBase64)
            local ret = Proto.decode(v.msgId, body)
            Message.DispatchMessage(v.msgId, v.code, ret)
        end)
    elseif code == RET.RET_GAME_NOT_UP_FINAL_INFO then
        ModelList.BattleModel:GetCurrModel():ReqQuitBingoGame(false)
    elseif code == RET.RET_GAME_NOT_EXIST then
        Event.Brocast(EventName.Game_Not_Exist_Msg)
    end
end

function BattleModel.GetCardCountAndPowerUpLevel()
    local cardCount = this:GetCurrModel():GetCardCount()
    local powerLevel = 1
    local power_num = #this:GetCurrModel():GetPowerUps()
    if power_num == 6 then  powerLevel = 2
   elseif  power_num == 9 then  powerLevel = 2 end
    return cardCount,powerLevel
end

--- 设置战斗双倍状态
function BattleModel.SetBattleDouble(activityStatus)
    --if activityStatus then
    --    for i = 1, #activityStatus do
    --        if activityStatus[i].id == ActivityTypes.doubleFood and activityStatus[i].value == 1 then
    --            this.Is_Battle_Double_Food_State = true
    --        elseif activityStatus[i].id == ActivityTypes.doublePuzzle and activityStatus[i].value == 1 then
    --            this.Is_Battle_Double_Puzzle_State = true
    --        elseif activityStatus[i].id == ActivityTypes.doubleCookies and activityStatus[i].value == 1 then
    --            this.Is_Battle_Double_Cookie_State = true
    --        end
    --    end
    --else
        this.Is_Battle_Double_Food_State = false
        this.Is_Battle_Double_Puzzle_State = false
        this.Is_Battle_Double_Cookie_State = false
    --end
end

--- 设置战斗双倍状态
function BattleModel:SetBattleCompetition(hasCompetition)
    this.Is_Battle_Competition = hasCompetition
end

--- 设置战斗双倍状态
function BattleModel:GetBattleCompetition()
    return this.Is_Battle_Competition and true or false
end

--- 备份战斗数据
function BattleModel:BackupLoadData(data)
    this.gameLoadData = data
end

function BattleModel:GetBackupLoadData()
    return this.gameLoadData
end

--- 战斗双倍状态
function BattleModel.GetBattleFoodDouble()
    return this.Is_Battle_Double_Food_State
end

--- 战斗双倍状态
function BattleModel.GetBattlePuzzleDouble()
    return this.Is_Battle_Double_Puzzle_State
end

--- 战斗双倍状态
function BattleModel.GetBattleCookeDouble()
    return this.Is_Battle_Double_Cookie_State
end
--- 战斗双倍状态
function BattleModel.GetBattleSuperMatch()
    return this.Is_Battle_SuperMatch
end

function BattleModel.UpdateBattleSuperMatchToggle(forceClose)
    if forceClose then
        this.Is_Battle_SuperMatch = false
    else
        local isOpen = this:GetCurrModel():GetBattleExtraInfo("mainMiniGameId") == 1 and true or false
        --this.Is_Battle_SuperMatch = isOpen
        this.Is_Battle_SuperMatch = false
    end
end

--- 选择玩法,（目前没有选择玩法界面，按城市来找对应玩法）
function BattleModel.SelectPlayMode()

end

--看是否自动盖章
function  BattleModel.GetIsAutoSign()
    return this.isAutoSign
end

--设置自动盖章
function BattleModel.SetIsAutoSign(flag)
    this.isAutoSign = flag
end

--设置是否小丑机台
function BattleModel.SetIsJokerMachine(flag)
    this.isJokerMachine = flag
end

function BattleModel:HasJokerCard()
    local jokerDta = ModelList.BattleModel:GetCurrModel():GetJokerCardData()
    return jokerDta and true or false
end

--是否小丑机台
function BattleModel.GetIsJokerMachine()
    return this.isJokerMachine and true or false
end

--是否有小丑喷球器
function BattleModel.SetHasJokerBallSprayer(flag)
    this.hasBallSprayer = flag
end

--是否有小丑喷球器
function BattleModel.HasJokerBallSprayer()
    return this.hasBallSprayer
end

function BattleModel.SetQuitBattle(flag)
    this.isQuitBattle = flag
end

function BattleModel.IsQuitBattle()
    return this.isQuitBattle
end

---  按城市来找对应玩法
function BattleModel.GetCurrPlayTypeByCity()
    return ModelList.CityModel.GetPlayIdByCity()
end

--- 获取主包Model
local function GetNormalModel(playID)
    local modelName = Csv.GetData("new_game_mode", playID, "model")
    if modelName then
        local model = ModelList[modelName]
        return model
    end
end

--- 检查是否热更模块
local function GetHotModel(playID)
    local modular = Csv.modular
    for i = 1, #modular do
        if modular[i].city_play_id == playID then
            this.RequireModuleLua(modular[i].modular_name)
        end
    end
    return GetNormalModel(playID)
end

---  按playID来找对应玩法
function BattleModel.GetModelByPlayID(playID)
    local tempModel = GetNormalModel(playID)
    --- 可能是模块Model,需要主动加载一次依赖
    if not tempModel and Csv.modular then
        tempModel = GetHotModel(playID)
    end
    return tempModel
end

function BattleModel:SetFourCardAuto(isOpen)
    this.four_card_auto = isOpen
end

function BattleModel.IsFourCardAuto()
    return this.four_card_auto
end

---开启加速
function BattleModel.setGameSpeed(Scale)
    fun.save_value("GameSpeed_value",Scale)
end

function BattleModel.getGameSpeed()
    local value = fun.read_value("GameSpeed_value", 1)
    return value 
end

--- 请求进入游戏，所有玩法的入口
function BattleModel:ReqEnterGame(cb)
    local playId = this.GetCurrPlayTypeByCity()
    local model = this.GetModelByPlayID(playId)
    if model then
        model:ReqEnterGame(cb)
    else
        log.r("没有找到对应的玩法  "..playId)
        fun.SafeCall(cb, false)
    end
end

function BattleModel:ResEnterGame(code,data)
    local playId = this.GetCurrPlayTypeByCity()
    local model = this.GetModelByPlayID(playId)
    if model and model.ResEnterGame then
        model:ResEnterGame(code,data)
    else
        log.r("没有找到对应的玩法  "..playId)
    end
end

--后端Bingo预结算
function BattleModel.ResBingoPreSeettle(code,data)
    log.log("BattleModel.ResBingoPreSeettle 后端Bingo预结算", code,data)
    if(code == RET.RET_SUCCESS)then
        this:GetCurrModel():SaveSettleData(data,code)
        this:GetCurrModel():SetReadyState(3)
        this:GetCurrModel():StopBattleMachine()
        --this:GetCurrModel():OnReceiveSettle()
        Event.Brocast(EventName.Event_Receive_Game_Settle_Data)
    else
        log.w("同步Bingo错误")
    end
end

--后端Bingo结算
function BattleModel.ResBingoSettle(code,data)
    log.log("BattleModel.ResBingoSettle 后端Bingo结算", code,data)
    if(code == RET.RET_SUCCESS)then
        this:GetCurrModel():SaveSettleData(data,code)
        --this:GetCurrModel():SetReadyState(5)
        --this:GetCurrModel():StopBattleMachine()
        --this:GetCurrModel():OnReceiveSettle()
        Event.Brocast(EventName.Event_Receive_Game_Settle_Data)
        Event.Brocast(EventName.Event_Receive_Real_Game_Settle_Data)
    else
        log.w("同步Bingo错误")
    end
end

--当前玩法收到摇球机数据
function BattleModel.ResponeBallShaker(code, data)
    if this:GetCurrModel() then
        this:GetCurrModel().ResponeBallShaker(code, data)
    end
end
--当前玩法收到摇球机数据
function BattleModel.ResponeBallShakerResult(code, data)
    if this:GetCurrModel() then
        this:GetCurrModel().ResponeBallShakerResult(code, data)
    end
end
--当前玩法收到金钱大厦数据
function BattleModel.ResponeMansionInfo(code, data)
    if this:GetCurrModel() then
        this:GetCurrModel().ResponeMansionInfo(code, data)
    end
end

this.MsgIdList = {
    {msgid = MSG_ID.MSG_PUSH_GAME_EXCEPTION, func = this.ResGameException},
    {msgid = MSG_ID.MSG_FETCH_SETTLE_DATA, func = this.ResFetchSettleData},
    {msgid = MSG_ID.MSG_GAME_COMMON_PRE_SETTLE, func = this.ResBingoPreSeettle},
    {msgid = MSG_ID.MSG_GAME_COMMON_SETTLE, func = this.ResBingoSettle},
    {msgid = MsgIDDefine.PB_BingoGameSettle, func = this.ResBingoSettle},

    ---通用的minigame-摇球器协议
    { msgid = MSG_ID.MSG_GAME_BALL_SHAKER_INFO, func = this.ResponeBallShaker },
    { msgid = MSG_ID.MSG_GAME_BALL_SHAKER_USE, func = this.ResponeBallShakerResult },
    --{ msgid = MSG_ID.MSG_GAME_MONEY_MANSION_FOR_MAIN_INFO, func = this.ResponeMansionInfo },
    --{ msgid = MSG_ID.MSG_GAME_MONEY_MANSION_FOR_MAIN_SPIN, func = this.ResponeMansionInfo },

}


--- 转换成服务器左下角坐标
function ConvertCellIndexToServerPos(clientPos)
    if clientPos and tonumber(clientPos) then
        local a = clientPos -1
        local c = math.modf(a / 5)
        local d = math.fmod(a, 5)
        return (c+1)*10+5-d
    else
        return 0
    end
end

--- 转换服务端坐标
function ConvertServerPos (serverPos)
    local c = math.modf(serverPos / 10)
    local d = math.fmod(serverPos, 10)
    return c * 5 - d + 1
end

local function copyfile(source,destination)
    local  destination = UnityEngine.Application.dataPath
    local  source = UnityEngine.Application.streamingAssetsPath
    print(destination)
    local path = source.."/lua/View/SpecialGameplay/SpecialGameplayView.lua"

    coroutine_fun = function()
        local www = UnityEngine.WWW(path)
        coroutine.wait(0.5)
        if www.isDone and not www.error then
            print(www.text)
        else
            log.r("www图片加载失败，错误信息："..www.error)
        end
    end
    coroutine.resume(coroutine.create(coroutine_fun))
end


--- 模块下载完，加载一下依赖
function BattleModel.RequireModuleLua (moduleName,moduleId)
    if moduleId then
        local portal_data = MachinePortalManager.get_portal_data_by_machine_id(moduleId)
        local version = MachineDownloadManager.read_machine_local_version(moduleId)
        if portal_data and version and  portal_data.version  then
            if  version >= portal_data.version then --已下载
                return
            end
        end
    end

    local success, req = pcall(require, "Module."..moduleName.."package")
    if success then
        req:LoadRequire()
    else
        log.r("缺少".."Module."..moduleName.."package")
    end

    this.LoadGamePassModule(moduleName,moduleId)

end


function BattleModel.LoadGamePassModule(moduleName,moduleId)


    local modularData = Csv.modular 
    local cityId = -1
    local modeltype = -1
    for k,v in pairs(modularData) do
       if(v.modular_name == moduleName ) then 
            cityId = v.city_play_id
            modeltype = v.modular_type
            break
       end
    end

    if(modeltype~=1)then 
        return -- 不是模块包，跳过
    end
    
    -- Csv.GetData("modular",tmpData.modular_id)
    local success, result = pcall(require, "Module."..moduleName.."AssetList")
    if success then
        local loadGamePassModule = ModelList.GameActivityPassModel.GetLoadModule()
        local isFind = false
        for k,v in pairs(loadGamePassModule) do
            local module = result[k]
            if(module)then
                isFind = true
                AssetList[k] = module
            end
        end
        if(isFind)then
            ModelList.GameActivityPassModel.SetCurrentId(cityId)
        end
    else
        ModelList.GameActivityPassModel.SetCurrentId(cityId)
    end
end



function BattleModel:IsCompetition()
    if self:GetCurrModel() then
        local data = self:GetCurrModel():GetBattleCompetitionGameInfo( )
        return  (data and  #data> 0 ) and true or false
    end
    return nil
end

--- 最近购卡话费
function BattleModel:SaveLastBuyCardCost( cost )
    self.lastBuyCardCost = cost
end

--- 最近购卡话费
function BattleModel:GetLastBuyCardCost(  )
    return self.lastBuyCardCost
end

function BattleModel:SetBattleBoxID(boxItemID)
    self.boxItemID = boxItemID
end

function BattleModel:GetBattleBoxID()
    local ret = self:GetCurrModel():GetBattleExtraInfo("battleBoxID")
    ret = ret or self.boxItemID
    return ret
end

------------------start region 拼图  cardPackage ------------------------------

--是否有拼图碎片奖励
function BattleModel:CheckHavePuzzleReward(cardId)
    if this.game_type ~= PLAY_TYPE.PLAY_TYPE_NORMAL then
        --只有主玩法展示碎片外框
        return
    end
    
    local cardsInfo, reward = this:GetCurrModel():GetCards()
    for i = 1, #cardsInfo do
        local cardInfo = cardsInfo[i]
        if not cardId or cardInfo.cardId == cardId then
            --找卡包奖励id
            reward = table.find(cardInfo.cardReward, function(k, v)
                return v.id == 601000
            end)
        end
    end
    return reward
end

------------------end region 拼图  cardPackage ------------------------------

------------------start region 卡包  cardPackage ------------------------------
--- 包含卡包的卡牌ID列表
function BattleModel:CardIdsContainCardPack(  )
    if not ModelList.BattleModel:GetCurrModel() then return nil end
    local cardsInfo = ModelList.BattleModel:GetCurrModel():GetCards()
    local cardIds = {}
    for i = 1, #cardsInfo do
        if cardsInfo[i].cardReward and #cardsInfo[i].cardReward > 0 then
            table.insert(cardIds, cardsInfo[i].cardId)
        end
    end
    return cardIds
end

--- 卡牌卡包奖励的icon
function BattleModel:GetBattleCardRewardIcon(cardID)
    local cardsInfo = ModelList.BattleModel:GetCurrModel():GetCards()
    local cardReward, iconName
    for i = 1, #cardsInfo do
        local cardInfo = cardsInfo[i]
        if not cardID or cardInfo.cardId == cardID then
            --找卡包奖励id
            cardReward = table.find(cardInfo.cardReward, function(k, reward)
                --local cardCfg = Csv.GetData("season_card_box", reward.id)
                local cardCfg = ModelList.SeasonCardModel:GetCardPackageInfo(reward.id)
                return cardCfg
            end)
            if cardReward then
                break
            end
        end
    end

    if cardReward then
        --取icon
        local Toolkit = require "View/SeasonCard/Toolkit"
        --iconName = Csv.GetData("season_card_box", cardReward.id,"icon")
        local cardCfg = ModelList.SeasonCardModel:GetCardPackageInfo(cardReward.id)
        iconName = cardCfg and cardCfg.icon
        iconName = Toolkit.GetBagBigIconName(iconName)
    end
    
    return iconName
end
------------------end region 卡包  cardPackage ------------------------------

function BattleModel:SetReadyForPreUseItem(useType)
    if this:GetCurrBattleView() then
        this:GetCurrBattleView():SetReadyForPreUseItem(useType)
    end
end

--- 是否得到进战斗数据
function BattleModel:HasGetBattleData()
    if ModelList.BattleModel:GetCurrModel() then
        return ModelList.BattleModel:GetCurrModel():GetReadyState()  >= 1
    end
    return false
end

--- 记录是否进入战斗失败，被迫返回大厅
function BattleModel:SetEnterBattleFail( isFail )
    this.isEnterBattleFail = isFail
end

--- 获取是否进入战斗失败，被迫返回大厅
function BattleModel:GetEnterBattleFail( )
    return this.isEnterBattleFail and true or false
end

function BattleModel:IsShowDetail()
    return this.isShowDetail and true or false
end

function BattleModel:SetShowDetail(isShow)
    this.isShowDetail = isShow
end

return this
