---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2021/9/7 14:47
---

local TaskModel = BaseModel:New("TaskModel")
local this = TaskModel

local mainTask = {} --主线任务
--local quickTask = {} --限时任务，只会有一条数据，当前完成提交了服务器才会推下一条
local dailyTask = {} --日常任务
local weeklyTask = {} --周常任务
local dailyReward = {} --日常阶段奖励
local weeklyReward = {} --周常阶段奖励

local taskSortList = {}

--local submitTask = nil

local dailyEndTime = nil
local weeklyEndTime = nil

local canGetRewardList = {}

local stageRewardReddot = {}

function TaskModel.C2S_FetchTask()
    --Http.req_fetch_task(0)
    this.SendMessage(MSG_ID.MSG_TASK_FETCH,{type = 0})
end

function TaskModel.Login_C2S_FetchTask()
    return MSG_ID.MSG_TASK_FETCH, Base64.encode(Proto.encode(MSG_ID.MSG_TASK_FETCH,{type = 0}))
    --Http.req_fetch_task(0)

end

function TaskModel.C2S_SubmitTask(data)
    --Http.req_submit_task(taskType,taskGroup,taskId)
    --log.r("================================>>C2S_SubmitTask " .. taskType .. " " .. taskGroup .. taskId)
    --submitTask = taskId
    ---原本就没有给ad参数赋值，先默认为0
    this.SendMessage(MSG_ID.MSG_TASK_RECEIVE_REWARD, { params = data })
end

function TaskModel.C2S_ClaimStageReward(taskType,stageIndex)
    this.SendMessage(MSG_ID.MSG_TASK_RECEIVE_STAGEREWARD,{taskType = taskType,stage = stageIndex})
end

function TaskModel.IsStageRwardAvailable(taskType)
    return stageRewardReddot[taskType]
end

function TaskModel.GetDailyTask()
    return taskSortList[TaskToggle.daily] or dailyTask
end

function TaskModel.NeedShowDailyTipShow()
    return this.HasDailyTaskChange
end

function TaskModel.HasDailyTaskOrWeekTask()
    --local hasUnComplete = false
    local daily = this.GetDailyTask()
    if daily and #daily>0 then
        for i = 1, #daily do
            if  not daily[i].rewarded then
                return true
            end
        end
    end
    local week =this.GetWeeklyTask()
    if week and #week>0 then
        for i = 1, #week do
            if  not week[i].rewarded then
                return true
            end
        end
    end
    return false
end

function TaskModel.ResetShowDailyTipShow()
    --log.r("HasDailyTaskChange    false")
    this.HasDailyTaskChange = false
end

---推送的任务，有没有未领取的
function TaskModel:DailyAndWeekTaskProcessChange(data)
    if data.dailyTask and #data.dailyTask > 0 then
        for i = 1, #data.dailyTask do
            if not data.dailyTask[i].rewarded then
                this.HasDailyTaskChange = true
                break
            end
        end
    end
    if not this.HasDailyTaskChange and data.weeklyTask and #data.weeklyTask > 0 then
        for i = 1, #data.weeklyTask do
            if not data.weeklyTask[i].rewarded then
                this.HasDailyTaskChange = true
                break
            end
        end
    end
end

function TaskModel.GetWeeklyTask()
    return taskSortList[TaskToggle.weekly] or weeklyTask
end

function TaskModel.GetMainTask()
    if mainTask then
        for key, value in pairs(mainTask) do
            if value then
                return value
            end
        end
    end
    return nil
end

function TaskModel.GetDailyStageReward()
    return dailyReward
end

function TaskModel.GetWeeklyStageReward()
    return weeklyReward
end

function TaskModel.GetStageRewardByType(stage,progress)
    local stageReward = nil
    if stage == TaskToggle.daily then
        stageReward = dailyReward
    elseif stage == TaskToggle.weekly then
        stageReward = weeklyReward
    end
    if progress == nil then
        return stageReward
    else
        for key, value in pairs(stageReward) do
            if value.stage == progress then
                return value
            end
        end    
    end
end

function TaskModel.GetDailyEndTime()
    return dailyEndTime or 0
end

function TaskModel.GetWeeklyEndTime()
    return weeklyEndTime or 0
end

function TaskModel.GetRewardInfo(taskType)
    return canGetRewardList[taskType] or {}
end

function TaskModel.IsAnyReward()
    for key, value in pairs(canGetRewardList) do
        if value.canGetReward then
            --return key,true
            return TaskToggle.daily,true
        end
    end
    if this.IsStageRwardAvailable(TaskToggle.daily) then
        return TaskToggle.daily,true
    end
    --if this.IsStageRwardAvailable(TaskToggle.weekly) then
    --    return TaskToggle.weekly,true
    --end
    return TaskToggle.daily,false
end

function TaskModel.S2C_FetchTask(code,data)
    --log.r("==========================>>S2C_FetchTask " .. tostring(data == nil))
    --log.log("sddsaddsadsadata",data)
    if code == RET.RET_SUCCESS then
        this.ResetTaskData()
        this.HasDailyTaskChange = false
        this.SetTask(TaskToggle.main,data.mainTask,mainTask,true)
        --this.SetTask(TaskToggle.quick,data.quickTask,quickTask,true)
        this.SetTask(TaskToggle.daily,data.dailyTask,dailyTask)
        this.SetTask(TaskToggle.weekly,data.weeklyTask,weeklyTask)
        dailyEndTime = data.dailyEndTime
        weeklyEndTime = data.weeklyEndTime
        this.SetRewardRedDotData(TaskToggle.main,mainTask)
        this.SetRewardRedDotData(TaskToggle.daily,dailyTask)
        this.SetRewardRedDotData(TaskToggle.weekly,weeklyTask)

        this.SetStageReward(TaskToggle.daily,data.dailyStage,dailyReward)
        this.SetStageReward(TaskToggle.weekly,data.weeklyStage,weeklyReward)

        RedDotManager:Refresh(RedDotEvent.task_reddot_event)
    end
end

function TaskModel.ResetTaskData()
    mainTask = {}
    --quickTask = {}
    dailyTask = {}
    weeklyTask = {}
    dailyReward = {}
    weeklyReward = {}
end

function TaskModel.S2C_UpdateTaskProcess(code,data)
    --log.r("==========================>>S2C_UpdateTaskProcess " .. tostring(data == nil))
    if code == RET.RET_SUCCESS then
        if this.SetTask(TaskToggle.main,data.mainTask,mainTask,true) == 1 then
            this.SetRewardRedDotData(TaskToggle.main,mainTask)
        end
        --this.SetTask(TaskToggle.quick,data.quickTask,quickTask,true)
        if this.SetTask(TaskToggle.daily,data.dailyTask,dailyTask) == 1 then
            this.SetRewardRedDotData(TaskToggle.daily,dailyTask)
        end
        if this.SetTask(TaskToggle.weekly,data.weeklyTask,weeklyTask) == 1 then
            this.SetRewardRedDotData(TaskToggle.weekly,weeklyTask)
        end 
    end
end

function TaskModel.S2C_ReceiveQuickTaskReward(code,data)
    --log.r("==========================>>S2C_ReceiveQuickTaskReward " .. tostring(data == nil))
    --log.r("====================================>>S2C_ReceiveQuickTaskReward " .. " code: " .. code)
    if code == RET.RET_SUCCESS then
        if data.taskType == TaskToggle.daily then
            RedDotManager:Refresh(RedDotEvent.task_reddot_event)
            elseif data.taskType == TaskToggle.passtask then

        end
        Event.Brocast(EventName.Event_GetTaskRewardSucceed)
    else
        Event.Brocast(EventName.Event_GetTaskRewardFail)

    end
end

function TaskModel.S2C_TaskInfoUpdate(code,data)
    --log.r("==========================>>S2C_TaskInfoUpdate " .. tostring(data == nil))
    if code == RET.RET_SUCCESS and data then
        if this.SetTask(TaskToggle.main,data.mainTask,mainTask,true) == 1 then
            this.SetRewardRedDotData(TaskToggle.main,mainTask)
        end
        if this.SetTask(TaskToggle.daily,data.dailyTask,dailyTask) == 1 then
            this.SetRewardRedDotData(TaskToggle.daily,dailyTask)
        end
        if this.SetTask(TaskToggle.weekly,data.weeklyTask,weeklyTask) == 1 then
            this.SetRewardRedDotData(TaskToggle.weekly,weeklyTask)
        end
        if data.taskPassTask and #data.taskPassTask>0 then
            ModelList.GameActivityPassModel.UpdatePassDataById(data.playId,"TaskDataComponent", data.taskPassTask)
        end

        this:DailyAndWeekTaskProcessChange(data)

        Event.Brocast(EventName.Event_TaskUpdate)
    end
end

function TaskModel.S2C_ClaimStageReward(code,data)
    if code == RET.RET_SUCCESS and data then
        this.SetStageReward(TaskToggle.daily,data.dailyStage,dailyReward)
        this.SetStageReward(TaskToggle.weekly,data.weeklyStage,weeklyReward)
        Event.Brocast(EventName.Event_GetTaskRewardSucceed)
        Event.Brocast(EventName.Event_TaskUpdate,0)
    end
end

function TaskModel.SetTask(taskType,taskdata,taskset,reset)
    local result = 0
    if taskdata and #taskdata > 0 then
        if reset then
            for key, value in pairs(taskset) do
                taskset[key] = nil
            end
        end
        for key, value in pairs(taskdata) do
            if value and value.taskId and value.taskId ~= 0 then
                result = 1
                taskset[tonumber(value.taskId)] = deep_copy(value)
            end
        end
    end
    local sortList = {}
    for key, value in pairs(taskset) do
        table.insert(sortList,value)
    end
    table.sort(sortList,function(a,b)
        --return tonumber(a.target) - tonumber(a.process) < tonumber(b.target) - tonumber(b.process)
        return  tonumber(a.process)/tonumber(a.target) >tonumber(b.process)/tonumber(b.target)
    end)
    taskSortList[taskType] = sortList
    return result
end

function TaskModel.SetRewardRedDotData(taskType,taskdata)
    local canGetReward = false
    local completed = 0
    local count = 0
    for key, value in pairs(taskdata) do
        count = count + 1
        if (value.completed and tonumber(value.process) >= tonumber(value.target) ) and (not value.rewarded)  then
            canGetReward = true
        end
        if value.rewarded then
            completed = completed + 1
        end
    end
    if taskType then
        canGetRewardList[taskType] = {canGetReward = canGetReward,completed = completed,count = count,isUpdata = true}
    end
    this.CheckStageRewardRedDot(taskType)
    if canGetRewardList[TaskToggle.main] and canGetRewardList[TaskToggle.main].canGetReward then
        Facade.SendNotification(NotifyName.HallCity.EnterCityPopupOrder,PopupOrderOccasion.forcePopup)
    end
end

function TaskModel.CheckStageRewardRedDot(taskType)
    local rewardData = this.GetRewardInfo(taskType)
    local stage = this.GetStageRewardByType(taskType)
    if stage and rewardData then
        local isReward = false
        for key, value in pairs(stage) do
            if not value.rewarded then
                if value.stage == 50 and (rewardData.completed / math.max(rewardData.count,1) >= 0.499 ) then
                    isReward = true
                    break
                elseif value.stage == 100 and (rewardData.completed / math.max(rewardData.count,1) >= 0.99 ) then
                    isReward = true
                    break     
                end
            end
        end
        stageRewardReddot[taskType] = isReward
    end
end

function TaskModel.SetStageReward(taskType,rewarddata,rewardset)
    if rewarddata then
        for key, value in pairs(rewarddata) do
            if value and value.stage then
                rewardset[value.stage] = deep_copy(value)
            end
        end
        this.CheckStageRewardRedDot(taskType)
    end
end

function TaskModel.CheckTopQuickTask()
    local task = this.GetQuickTask()
    return task and math.max(0,task.expireTime - os.time()) > 0
end

this.MsgIdList =
{
    {msgid = MSG_ID.MSG_TASK_FETCH ,func = this.S2C_FetchTask},
    {msgid = MSG_ID.MSG_TASK_UPDATE_PROGRESS_NOTIFY, func = this.S2C_UpdateTaskProcess},
    {msgid = MSG_ID.MSG_TASK_RECEIVE_REWARD, func = this.S2C_ReceiveQuickTaskReward},
    {msgid = MSG_ID.MSG_TASK_NEW_NOTIFY, func = this.S2C_TaskInfoUpdate},
    {msgid = MSG_ID.MSG_TASK_RECEIVE_STAGEREWARD,func = this.S2C_ClaimStageReward}
}

return this