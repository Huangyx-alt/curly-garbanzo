---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2023/5/16 10:08
---
---@class AppEventTimerModel : BaseModel
local AppEventTimerModel = BaseModel:New("AppEventTimerModel")
local this = AppEventTimerModel

---通用定时器
local eventTimers = {}
---所有的延迟定时器
local totalEventTimers = {}
---循环检查定时器
local loopCheckResMessageIds = {}

--拉取消息定时器
local requestTimer = {}

--消息定时器合集
local requestTimerInvndle = {}

--开始消息定时器合集
local requestTimerStart = {}

local loopCheckResMessageTimer = nil

local eventTimerCheckInterval = 100

--function AppEventTimerModel:InitData()
--
--end

function AppEventTimerModel:SetLoginData(data)
    this:ClearTimers()
    if data then
        if data.eventTimer then
            eventTimers = deep_copy(data.eventTimer)
        else
            eventTimers = {}
        end
        if data.eventTimerCheckInterval then
            eventTimerCheckInterval = data.eventTimerCheckInterval
        else
            eventTimerCheckInterval = nil
        end 

        if data.eventIntervalTimer then 
            this:TimerStart(data.eventIntervalTimer)
        end     


    else
        eventTimers = {}
        eventTimerCheckInterval = nil
    end

    this:SetAppTimer()
    this:StartIntervalCheckEventTimer()
end

function AppEventTimerModel:SetAppTimer()
    if eventTimers and #eventTimers >0 then
        local currTime = ModelList.PlayerInfoModel.get_cur_server_time()
        for i = 1, #eventTimers do
            if eventTimers[i] and eventTimers[i].expireTime then
                --if v.type == EVENT_TIMER_TYPE.AD_RESET then
                local timer = LuaTimer:SetDelayFunction(eventTimers[i].expireTime- currTime +5 , function()
                    this:CheckTimer()
                end)
                this:AddTimer(timer)
                --end
            end
        end
    end
end

---检查定时器
function AppEventTimerModel:StartIntervalCheckEventTimer()
    if eventTimerCheckInterval then
      local checkInterval =   LuaTimer:SetDelayFunction(eventTimerCheckInterval, function()
            this:ReqEventTimer()
        end)
        this:AddTimer(checkInterval)
    end
end

---检查定时器
function AppEventTimerModel:CheckTimer()
    if eventTimers and #eventTimers > 0 then
        if (type(eventTimers) ~= "table") then
            return
        end
        local currTime = ModelList.PlayerInfoModel.get_cur_server_time()
        for i = 1, #eventTimers do
            if eventTimers[i] and type(eventTimers[i]) ~= "number" then
                if eventTimers[i].type == EVENT_TIMER_TYPE.AD_RESET then
                    if eventTimers[i].expireTime - currTime <= 0 then
                        this.SendMessage(MSG_ID.MSG_AD_COUNT_NOTIFY, {})
                        this:LoopCheckResMessage(MSG_ID.MSG_AD_COUNT_NOTIFY)
                    end
                else
                    if eventTimers[i].type == EVENT_TIMER_TYPE.ANNIVERSARY_BEGIN then
                        if eventTimers[i].expireTime - currTime <= 0 then
                            this:triggerTimeEvent(EVENT_TIMER_TYPE.ANNIVERSARY_BEGIN)
                        end
                    end
                end
            end
        end
    end
end

---请求的数据没有收到返回，则循环请求
function AppEventTimerModel:LoopCheckResMessage(msgid)
    if not loopCheckResMessageIds then
        loopCheckResMessageIds = {}
    end
    if fun.is_include(msgid,loopCheckResMessageIds) then
        return
    end
    table.insert(loopCheckResMessageIds, msgid)
    if not loopCheckResMessageTimer then
        loopCheckResMessageTimer = LuaTimer:SetDelayLoopFunction(5, 5, 1000, function()
            if loopCheckResMessageIds and #loopCheckResMessageIds  == 0 then
                LuaTimer:Remove(loopCheckResMessageTimer)
                loopCheckResMessageTimer = nil
                return
            end
            if loopCheckResMessageIds and #loopCheckResMessageIds > 0 then
                for i = 1, #loopCheckResMessageIds do
                    if loopCheckResMessageIds[i] then
                        this.SendMessage(loopCheckResMessageIds[i], {})
                    end
                end
            end
        end)
    end
end

---请求的数据没有收到返回，则循环请求
function AppEventTimerModel:RemoveLoopCheckResMessage(msgid)
        if loopCheckResMessageIds and #loopCheckResMessageIds > 0 then
            for i = 1, #loopCheckResMessageIds do
                if loopCheckResMessageIds[i] == msgid then
                    table.remove(loopCheckResMessageIds, i)
                    break
                end
            end
        end
        if loopCheckResMessageIds and #loopCheckResMessageIds  == 0 and loopCheckResMessageTimer then
            LuaTimer:Remove(loopCheckResMessageTimer)
            loopCheckResMessageTimer = nil
        end
end

function AppEventTimerModel:AddTimer(data)
    if data then
        table.insert(totalEventTimers, data)
    end
end


function AppEventTimerModel:ClearTimers()
    if totalEventTimers and #totalEventTimers>0 then
        for i,v in ipairs(totalEventTimers) do
            if v then
                LuaTimer:Remove(v)
            end
        end
    end
    
    if requestTimerStart and # requestTimerStart >0 then 
        for i,v in ipairs(requestTimerStart) do
            if v then
                LuaTimer:Remove(v)
            end
        end
    end 

    if requestTimerInvndle and # requestTimerInvndle >0 then 
        for i,v in ipairs(requestTimerInvndle) do
            if v then
                LuaTimer:Remove(v)
            end
        end
    end 

    requestTimerStart = {}
    totalEventTimers = {}
    requestTimerInvndle={}
end

--启用定时器事件 
function AppEventTimerModel:TimerStart(data)
    if not data   then 
        return 
    end 

    for _,v in ipairs(data) do 
       this:triggerDelayTimeEvent(v)
    end 

end

function AppEventTimerModel:triggerDelayTimeEvent(data)
    local currTime = ModelList.PlayerInfoModel.get_cur_server_time()
    local invokeTime = data.beginTime - currTime

    if invokeTime < 0 then 
        return 
    end 
    
    local TimeStart = LuaTimer:SetDelayFunction(invokeTime, function() 

        --检测时间节点是否合规，在误差内允许，误差外，需要递归调用
        local checkCurrTime = ModelList.PlayerInfoModel.get_cur_server_time() 
        local checkCdTime = data.beginTime - checkCurrTime
        log.g("时间内的误差"..tostring(checkCdTime))
        if checkCdTime > 50 then 
            this:triggerDelayTimeEvent(data)
            return 
        end 

        local TimeInvoke =  LuaTimer:SetDelayLoopFunction(0,  data.interval, data.times, function()

            this:triggerTimeEvent(data.type)
        end)
      
        requestTimerInvndle[data.type] = TimeInvoke
    end,nil,nil)

    table.insert( requestTimerStart, TimeStart)
end 

function AppEventTimerModel:triggerTimeEvent(type)
    if not type then 
        log.r("error error ")
    end 

    --给定开始时间定时查询周榜结算
    if type == EVENT_TIMER_TYPE.WEEKLY_SETTLE then
        this.SendMessage(MSG_ID.MSG_GET_WEEK_SETTLE_STATUS, {})
    elseif type == EVENT_TIMER_TYPE.FAME_SETTLE then
        this.SendMessage(MSG_ID.MSG_FAME_SETTLE_STATUS, {})
    elseif type == EVENT_TIMER_TYPE.ANNIVERSARY_BEGIN then
        if ModelList.CompetitionModel:GetPlayerChooseId() == COMPETITION_TYPE.COMPETITION_RACING then
            this.SendMessage(MSG_ID.MSG_COMPETITION_RACING_FETCH, {})
        else
            this.SendMessage(MsgIDDefine.PB_CookieFetch, {type = 2})
        end
    end 
end 

function AppEventTimerModel:OnGetNotify(msgid)
    if msgid == MSG_ID.MSG_AD_COUNT_NOTIFY then
        this:ReqEventTimer()
        this:RemoveLoopCheckResMessage(msgid)
    end
end

function AppEventTimerModel:ReqEventTimer()
    this.SendMessage(MSG_ID.MSG_EVENT_TIMER_NEW, {})
end

function AppEventTimerModel.ResNewEventTimer(code, data)
    this:SetLoginData(data)
end

function AppEventTimerModel.WeekNewrAnkResNewEventTimer(code, data)

    if data ~= nil then 
        --拉取周榜奖励
        if data.code == "0" then 
            if requestTimerInvndle[EVENT_TIMER_TYPE.WEEKLY_SETTLE] ~= nil then 
                LuaTimer:Remove(requestTimerInvndle[EVENT_TIMER_TYPE.WEEKLY_SETTLE])  
                requestTimerInvndle[EVENT_TIMER_TYPE.WEEKLY_SETTLE] = nil
            end 
    
            --0 是查询，1 是领奖
            this.SendMessage(MSG_ID.MSG_WEEK_NEW_RANK_REWARD, {receive =0})

        end 
       
    end 
  

end 

function AppEventTimerModel.FameEventTimer(code, data)
    if data ~= nil then 
        --拉取奖励
        if data.code == "0" then 
            if requestTimerInvndle[EVENT_TIMER_TYPE.FAME_SETTLE] ~= nil then 
                LuaTimer:Remove(requestTimerInvndle[EVENT_TIMER_TYPE.FAME_SETTLE])  
                requestTimerInvndle[EVENT_TIMER_TYPE.FAME_SETTLE] = nil
            end 
    
            --0 是查询，1 是领奖
            this.SendMessage(MSG_ID.MSG_FAME_REWARD, {receive =0})
        end
    end
end 

--function AppEventTimerModel:ResNewEventTimer(code, data)
--    this:SetLoginData(data)
--end

this.MsgIdList =
{
    {msgid = MSG_ID.MSG_EVENT_TIMER_NEW,func = this.ResNewEventTimer},
    {msgid = MSG_ID.MSG_GET_WEEK_SETTLE_STATUS,func = this.WeekNewrAnkResNewEventTimer},
    {msgid = MSG_ID.MSG_FAME_SETTLE_STATUS,func = this.FameEventTimer},
}

return this