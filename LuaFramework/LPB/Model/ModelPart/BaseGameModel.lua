---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2021/11/12 19:06
---
require 'Model/BaseModel'
local setmetatable = setmetatable;

require("Combat.Machine.CallNumber.CallNumberMachine")
require("Combat/Machine/CalculateBingoMachine")
require("Combat/Machine/BingoLeftTickMachine")
require("Combat/Machine/BingoOrderMachine")
require("Combat.Machine.BattleMachineList")
local bingoJokerMachine = require("Combat.Machine.BingoJokerMachine")
local roundData =  require("Combat.Data.RoundData")

---@class BaseGameModel
BaseGameModel = BaseModel:New("BaseGameModel")
local this = BaseGameModel

this.uploadData = require 'Model/ModelPart/UploadBattleData'
this.__index = this

this.currNumber = 0                         --当前叫号
this.bingoLeftData = nil                    --最新bingoleft数据
this.totalNumber = {}                         --所有叫号
this.settle = nil                                      --结算数据
this.settleCode = nil                                      --结算数据
this.roundData = {}                               --点击的数据
this.game_data_ready_state = 0
this.game_type = PLAY_TYPE.PLAY_TYPE_NORMAL
this.game_state = GameState.Ready
this.bingoRobots = {}
this.num_to_index = {}                               --数字转成索引列表
this.bingoEffectDelayTime = 0
local bingoInfoQueue = {}

function BaseGameModel:New()
    local o = {}
    setmetatable(o, { __index = BaseGameModel });
    return o
end

--初始化状态
function BaseGameModel:SetInit(state)
    self._init = state and true or false
end
function BaseGameModel:IsInit()
    return self._init and true  or false
end

--设置游戏类型
function BaseGameModel:SetSelfGameType(battle_type)
    self.game_type = battle_type
end
function BaseGameModel:GetGameType()
    return self.game_type
end

--清理基础数据
function BaseGameModel:Clear()
    this.game_state = GameState.Ready
    this.currNumber = 0                         --当前叫号
    this.bingoLeftData = nil                    --最新bingoleft数据
    this.totalNumber = {}                         --所有叫号
    this.settle = nil                                      --结算数据
    this.roundData = {}                               --点击的数据
    this.game_data_ready_state = 0
    this.bingoRobots = {}
    this.num_to_index = {}
    bingoInfoQueue = {}
    this.bingoEffectDelayTime = 0
    this.matchChargeRewardIdList = nil
    this:CancelLoopUpFinnalInfo()
    Event.Brocast(EventName.Event_stop_bingo_game)
end

function BaseGameModel:SetModelView(model_view)
    ---@type GameCardView
    this.view = model_view
end

-----------------游戏阶段状态------------------------------------------------------------------------------------------------------------

--设置游戏状态
function BaseGameModel:SetGameState(state)
    this.game_state = state
    ModelList.BattleModel:SetGameState(state)
    if state == GameState.Ready then
        Event.Brocast(EventName.Event_Loading_Game_Receive_Battle_Data)
    end
end

function BaseGameModel:GetGameState()
    return this.game_state
end

---收到后端数据，设置准备状态
function BaseGameModel:SetReadyState(state)
    --此处有个问题，战斗出来没有清理数据，重新清理一遍
    if state == 0 and state < this.game_data_ready_state then
        ModelList.BattleModel.QuitBattle()
    end
    if state > this.game_data_ready_state or state == 0 then
        this.game_data_ready_state = state
    end
end

function BaseGameModel:GetReadyState()
    return this.game_data_ready_state
end

--是否正在游戏中
function BaseGameModel:IsGameing()
    return this.game_data_ready_state > 0
end

--是否游戏结束了
function BaseGameModel:IsGameOver()
    return this.game_data_ready_state >= 2
end

--结算中
function BaseGameModel:IsGameSettling()
    return this.game_data_ready_state == 3 or this.settle ~= nil
end

--可以
function BaseGameModel:IsReadyEnterScene()
    return this.game_data_ready_state == 1
end

-----------------后端数据--------------------------------------------------------------------------------------------------------------

function BaseGameModel:SaveGameLoadData(data)
    this.gameLoadData = data
end

--获取本局初始化游戏数据
function BaseGameModel:LoadGameData()
    return this.gameLoadData
end

function BaseGameModel:GetGameId()
    return this.gameLoadData.gameId
end

--获取bingo棋盘手牌
function BaseGameModel:GetCards()
    return this.gameLoadData.cardsInfo
end

function BaseGameModel:GetLoadCardInfo(cardID)
    cardID= tonumber(cardID)
    local find = table.find(this.gameLoadData and this.gameLoadData.cardsInfo, function(k, info)
        return info.cardId == cardID
    end)
    return find
end

--获取当前卡牌套数
function BaseGameModel:GetCardCount()
    return #this.gameLoadData.cardsInfo
end

function BaseGameModel:GetPowerUps()
    if not this.gameLoadData.powerUpData then
        this.gameLoadData.powerUpData = {}
    end
    return this.gameLoadData.powerUpData
end

--- 获取完整机器人ID列表
function BaseGameModel:GetAllRobots()
    if not this.gameLoadData or not this.gameLoadData.robotIds then
        this.gameLoadData = ModelList.BattleModel:GetBackupLoadData()
    end
    return this.gameLoadData.robotIds
end

--- 获取小丑卡列表
function BaseGameModel:GetJokerCardData()
    if this.gameLoadData 
            and this.gameLoadData.jokerData 
            and #this.gameLoadData.jokerData >0 then
        return this.gameLoadData.jokerData
    end
    return nil
end

--- 获取supermatch数据
function BaseGameModel:GetSuperMatchData()
    if this.gameLoadData then
        return this.gameLoadData.matchData
    end

    return nil
end

function BaseGameModel:GetGroupBagOpenItem(itemId, needRemove)
    if needRemove == nil then
        needRemove = true
    end
    for i = 1, #this.gameLoadData.groupBagOpenItem do
        if this.gameLoadData.groupBagOpenItem[i].itemId == itemId then
            if #this.gameLoadData.groupBagOpenItem[i].bagOpenItem > 0 then
                local data = deep_copy(this.gameLoadData.groupBagOpenItem[i].bagOpenItem[1])
                if needRemove then
                    table.remove(this.gameLoadData.groupBagOpenItem[i].bagOpenItem, 1)
                end
                return data
            end
        end
    end
    return nil
end

--是否开启了放大镜
function BaseGameModel:IsOpenMirror()
    return this.gameLoadData.systemTime <= this.gameLoadData.hintTime
end

function BaseGameModel:InitExtraData(data)
    self.enter_game_extra_data = nil
    if data then
        self.enter_game_extra_data = JsonToTable(data)
    end
    if self.enter_game_extra_data and self.enter_game_extra_data.competition then
        ModelList.BattleModel:SetBattleCompetition(( self.enter_game_extra_data and self.enter_game_extra_data.competition and
                self.enter_game_extra_data.competition.mark   )  and true or false)
    else
        ModelList.BattleModel:SetBattleCompetition(false)
    end
end

function BaseGameModel:GetBattleMiniGameInfo(params)
    if self.enter_game_extra_data and self.enter_game_extra_data.miniGame then
        if params then
            return self.enter_game_extra_data.miniGame[params]
        else
            return self.enter_game_extra_data.miniGame
        end
    end
end

function BaseGameModel:GetBattleCompetitionGameInfo(params)
    if self.enter_game_extra_data and self.enter_game_extra_data.competition then
        if params and self.enter_game_extra_data.competition[params] then
            return self.enter_game_extra_data.competition[params]
        else
            return self.enter_game_extra_data.competition
        end
    end
    return nil
end

function BaseGameModel:GetBattleExtraInfo(typeName, params)
    if self.enter_game_extra_data and self.enter_game_extra_data[typeName] then
        if params and self.enter_game_extra_data[typeName][params] then
            return self.enter_game_extra_data[typeName][params]
        else
            return self.enter_game_extra_data[typeName]
        end
    end
    return nil
end


-----------------叫号模块---------------------------------------------------------------------------------------------------------------
this.currNumber = {}
function BaseGameModel:GetCurrCallNumber()
    return this.currNumber
end

function BaseGameModel:SetNewCallNumber(syncNumber)
    this.currNumber = syncNumber
end

function BaseGameModel:IsCalledNumber(num)
    for i = 1, #this.totalNumber do
        if this.totalNumber[i] == num then
            return true
        end
    end
    return false
end

function BaseGameModel:AddCalledNumber(num)
    table.insert(this.totalNumber, num)
end

function BaseGameModel:GetCalledNumber()
    return this.totalNumber
end

-----------------bingoLeftData------------------------------------------------------------------------------------------------------
function BaseGameModel:LoadBingoLeftData()
    return this.bingoLeftData
end

function BaseGameModel:SaveBingoLeftInfo(new_data)
    this.bingoLeftData = new_data
    this:SaveBingoRobots(new_data.robots)
end

function BaseGameModel:SaveBingoRobots(new_data)
    this.bingoRobots = fun.merge_array(this.bingoRobots, new_data)
end

function BaseGameModel:GetBingoRobots()
    if #this.bingoRobots > 0 then
        local info = this.bingoRobots[1]
        table.remove(this.bingoRobots, 1)
        return info
    else
        log.r(" Error : 机器人 头像ID 不足")
        return -1
    end
end

local DelayShowBingoRefresh = function(data, cb)
    if data and #data > 0 then
        local bingo_table = {}
        for i = 1, #data do
            local id = data[i].cardId
            local info_type = data[i].type
            local total_count = data[i].totolCount
            local thRank = data[i].th
            if data[i].numbers then
                for k = 1, #data[i].numbers do
                    this:RefreshRoundDataByIndex(id, data[i].numbers[k], data[i].type + 1)
                end
            end
            local mIndex = tostring(id)
            local jackpot_count = 0
            if info_type == 2 then
                jackpot_count = 1
            end
            local cardId = tonumber(mIndex)
            if not fun.is_key_include(cardId, bingo_table) then
                bingo_table[cardId] = { index = mIndex, bingo = total_count, jackpot = jackpot_count,
                                        first_num = data[i].numbers and data[i].numbers[1] or nil,
                                        th = { thRank }, startCount = total_count,
                                        data = data[i]}
            else
                bingo_table[cardId].bingo = bingo_table[cardId].bingo > total_count and bingo_table[cardId].bingo or total_count
                bingo_table[cardId].jackpot = bingo_table[cardId].jackpot + jackpot_count
                if thRank > 0 then
                    table.insert(bingo_table[cardId].th, thRank)
                end
            end
        end
        --log.r("CardBingoEffect_ShowBingo  ")
        Event.Brocast(EventName.CardBingoEffect_ShowBingo, bingo_table, cb)
        Event.Brocast(EventName.SoundMachine_Bingo_Audio, bingo_table)
    end
end

--- 卡面上的bingo表现有延迟，确保最新一个bingo效果能满足最低存活时间
function BaseGameModel:IsBingoShowComplete()
    --local gameType = ModelList.BattleModel:GetGameCityPlayID()
    --local bingoMinAliveTime = Csv.GetData("new_game_effect_cache",gameType,"bingo_effect_min_alive_time")*0.001 or 0
    --
    --local checkTime = os.time() - this.bingoEffectDelayTime > bingoMinAliveTime
    --local checkRemainBingo = #bingoInfoQueue == 0
    --local checkRocketBingo = BattleLogic.GetLogicModule(LogicName.Card_logic) and not BattleLogic.GetLogicModule(LogicName.Card_logic):HasRocketBingo()
    --if BattleLogic.GetLogicModule(LogicName.Card_logic) then
    --    return checkTime and checkRemainBingo and checkRocketBingo
    --else
    --    return checkTime and checkRemainBingo
    --end
    return true
end

--形成Bingo，刷新bingo信息
function BaseGameModel:RefreshBingoInfo(delayTime)
    if this.bingoLeftData.bingo and #this.bingoLeftData.bingo > 0 then
        local bingoInfo = deep_copy(this.bingoLeftData.bingo)
        table.insert(bingoInfoQueue,bingoInfo)
    end
    this.bingoEffectDelayTime = os.time()
end

function BaseGameModel:ShowBingoRefresh(cb)
    if #bingoInfoQueue >0 then
        local data = bingoInfoQueue[1]
        table.remove(bingoInfoQueue,1)
        DelayShowBingoRefresh(data, cb)
    else
        fun.SafeCall(cb)
    end
end


-----------------卡面数据------------------------------------------------------------------------------------------------------------

function BaseGameModel:InitRoundData()
    roundData:CreateRoundData()
    this.roundData =  roundData
end

--- 单元格开启美食篮子
function BaseGameModel:SetCellBasketInfo(card_id, cellIndex,basketInfo,itemId)
    this.roundData:SetCellBasketInfo(card_id, cellIndex,basketInfo,itemId)
end

--- 单元格开启美食篮子,把美食篮子ID移入新位置，使用获得的美食替换美食篮子
function BaseGameModel:SetCellBasketInfo(card_id, cellIndex,basketInfo,itemId)
    this.roundData:SetCellBasketInfo(card_id, cellIndex,basketInfo,itemId)
end

function BaseGameModel:GetCellBasketReward(card_id, cellIndex,itemId)
    this.roundData:GetCellBasketReward(card_id,cellIndex,itemId)
end

function BaseGameModel:IsWishState(card_id, cellIndex)
   return  this.roundData:GetWishState(card_id, cellIndex) >0
end

function BaseGameModel:GetIndexByNum(card_id, num)
    return this.roundData:GetIndexByNum(card_id, num)
end

--- roundData数据示例，具体数据结构参考RoundData.lua
-- roundData["1190"] = {isBingo = false,isJackpot = false,cards = { {num = this.gameLoadData.cardsInfo[i].numbers[j], sign = 0, index = j} }}
--获取卡牌点击情况
function BaseGameModel:GetRoundData(cardid,cell_index)
    ---Model/ModelPart/BaseGameModel:551: attempt to call method 'GetCell' (a nil value)  收集的报错
    if this.roundData then
        if cell_index and this.roundData["GetCell"] then
            return this.roundData:GetCell(cardid,cell_index)
        elseif cardid  and this.roundData["GetCard"] then
            return this.roundData:GetCard(cardid)
        elseif this.roundData["GetRoundData"] then
            return this.roundData:GetRoundData()
        end
    end
    return nil
end

function BaseGameModel:AddDoubleNum(data)
    ---Model/ModelPart/BaseGameModel:551: attempt to call method 'GetCell' (a nil value)  收集的报错
    if this.roundData and this.roundData["GetRoundData"]  then
            this.roundData:AddDoubleNum(data)
    end
end

function BaseGameModel:GetRoundDataByNum(cardid,num)
    return this.roundData:GetRoundDataByNum(cardid,num)
end

function BaseGameModel:SetRoundDoubleData(card_id,cell_index,new_number)
    this.roundData:SetDoubleData(card_id,cell_index,new_number)
end

function BaseGameModel:OnlyRefreshRoundDataByIndex(cardid, cellIndex,  mark)
    local mIndex = tostring(cardid)
    local cell = this.roundData:GetCell(mIndex, cellIndex)
    if mark and cell.sign == 0 then
        cell:SetMark(mark)
        cell:SetLogicSign(1)
    end
end

--powerup 卡片签章
function BaseGameModel:SignCardWithPowerUpByIndex(tCardId, cellIndex, need_fly_item, mark,extraPos)
    local isSuccesClick =  self:RefreshRoundDataByIndex(tCardId, cellIndex, 1, need_fly_item, mark,extraPos)
    if isSuccesClick then
        this:CalcuateBingo(tCardId, cellIndex)
    end
    Event.Brocast(EventName.Switch_View_Refresh,{{cardId = tCardId,index = 0}})
end

---@param mark  --盖章方式 0=叫号 powerUpId=powerUp盖章的powerUpId  9=小火箭
function BaseGameModel:RefreshRoundDataByIndex(cardid, cellIndex, signType, need_fly_item, mark,extraPos,signSuccCall)
    local mIndex = tostring(cardid)
    signType = signType or 0
    if nil == need_fly_item then
        need_fly_item = true
    end
    local cell = this.roundData:GetCell(mIndex, cellIndex)
    if cell.sign == 0 then
        if  bingoJokerMachine:CheckJoker(cell:GetJokerChange(),mark) then
            return  --- 触发小丑吹吹卷，只刷新数据，表现延迟
        end
    end
    if mark and cell.sign == 0 then
        cell:SetMark(mark)
    end
    if cell == nil then
        log.r("data null " .. cardid .. "   " .. cellIndex .. "   " .. signType)
    end
    if cell:GetSignType()  <= signType then
        local oriSignType = cell.sign
        cell:SetSignType(signType)
        --log.b("RefreshRoundData  -- " .. mIndex .. "    " .. cellIndex .. "     " .. signType .. "    " .. tostring(need_fly_item))
        local self_bingo = cell.self_bingo
        local giftLen = #cell.gift
        Event.Brocast(EventName.Refresh_CardSign, mIndex, cellIndex, signType, self_bingo, giftLen)

        if oriSignType == 0 then
            if this.game_type ~= PLAY_TYPE.PLAY_TYPE_AUTO_TICKET then
                if cell.gift and #cell.gift > 0 then
                    if ModelList.BattleModel:GetCurrBattleView():IsCardShowing(mIndex) then --模拟飞道具
                        --Event.Brocast(EventName.Cell_Item_FlyTo_Box, mIndex, cellIndex, need_fly_item, cell.gift)
                        Event.Brocast(EventName.Cell_Item_Get, mIndex, cellIndex, cell.gift)
                    else
                        --Event.Brocast(EventName.Hide_Cell_Item_Box, mIndex, cellIndex, need_fly_item, cell.gift)
                        Event.Brocast(EventName.Hide_Cell_Item_Get, mIndex, cellIndex, cell.gift)
                    end
                end
            else
                Event.Brocast(EventName.Hide_Cell_Bg, cardid, cellIndex)
                --if signType == 1 and cell.gift and #cell.gift > 0 then
                if cell.gift and #cell.gift > 0 then
                    --模拟飞道具
                    --Event.Brocast(EventName.Cell_Item_FlyTo_Box, mIndex, cellIndex, need_fly_item, cell.gift)
                    Event.Brocast(EventName.Cell_Item_Get, mIndex, cellIndex, cell.gift)
                end
            end
            local skill_id = cell.skill_id
            if skill_id and #skill_id > 0 then
                --有宠物技能
                for k = 1, #skill_id do
                    --log.b("skill_id[k]  "..skill_id[k].."  mIndex "..mIndex.."  cellIndex "..cellIndex)
                    local powerId = nil
                    if #cell.powerId>=k then powerId = cell.powerId[k] end
                    if ModelList.BattleModel:IsRocket() then
                        extraPos  = self:GetRocketExtraPosData(cardid,cellIndex)
                    elseif Csv.GetData("skill",skill_id[k],"skill_type") == 1 then
                        extraPos = this.roundData:GetCell(mIndex, cellIndex):GetPuExtraPos()
                    elseif Csv.GetData("skill",skill_id[k],"skill_type") == 7 then
                        extraPos = this.roundData:GetCell(mIndex, cellIndex):GetPuExtraPos()
                    end
                    Event.Brocast(EventName.CardPower_Pet_Skill, skill_id[k], mIndex, cellIndex, powerId,extraPos)
                end
            end
        end

        if signType == 2 then
            this.roundData:CardBeBingo(mIndex)
        elseif signType == 3 then
            this.roundData:CardBeJackpot(mIndex)
        elseif signType == 1 and self_bingo then
            this.roundData:CardBeBingo(mIndex)
            cell:SetSignType(2)
        end
        
        if signSuccCall then
            signSuccCall()
        end
        if ModelList.GMModel.isSaveBattleData then
            Event.Brocast(EventName.Recorder_Data, 5003, { 
                cardId = cardid,
                cellIndex = cellIndex, 
                signType = signType, 
                need_fly_item = signType, 
                mark = mark 
            })
        end
        return true, self_bingo
    else
        --log.r("sign error   curr " .. cell.sign .. "  signType " .. signType)
        return false
    end
end

function BaseGameModel:RemoveCellGift(itemID, cardId, cellIndex)
    this.roundData:RemoveGift(itemID, cardId, cellIndex)
end

function BaseGameModel:SetRoundGiftData(card_id,cell_index,new_gift,number,skill_id, self_bingo,powerId,extraPos)
    local cardId = tostring(card_id)
    --log.b("SetRoundGiftData    "..cardId.."    "..cell_index.." new_gift  "..new_gift)
    this.roundData:SetNewGift(cardId,cell_index,new_gift)
    local gift_result =  Csv.GetData("new_item", new_gift,"result")
    if gift_result  and gift_result[1] == 13 then
        self_bingo = 1
    end
    if skill_id and skill_id ~= 0 then
        this.roundData:SetNewSkill(cardId,cell_index,skill_id)
    end
    if self_bingo and self_bingo ~= 0 then
        this.roundData:SetSelfBingo(cardId,cell_index)
    end
    if powerId and powerId ~= 0 then
        this.roundData:AddPowerId(cardId,cell_index,powerId,extraPos)
    end
    Event.Brocast(EventName.Recorder_Data,5006,{cardId = card_id,
                                                cellIndex = cell_index,newGift= new_gift,number = number,skillId = skill_id,
                                                selfBingo =self_bingo,powerId = powerId,powerIndex = RecorderMachine.powerIndex})
end

--- 隐藏在背后，不显示在格子上面的道具
function BaseGameModel:SetRoundHideGiftData(card_id,cell_index,extraItem)
    local cardId = tostring(card_id)
    this.roundData:SetHideGift(cardId,cell_index,extraItem)
    --Event.Brocast(EventName.Recorder_Data,5006,{cardId = card_id,
    --                                            cellIndex = cell_index,newGift= new_gift,number = number,skillId = skill_id,
    --                                            selfBingo =self_bingo,powerId = powerId,powerIndex = RecorderMachine.powerIndex})
end

function BaseGameModel:ChangeWishState(cardId,cellIndex,state)
    this.roundData:ChangeWishState(cardId,cellIndex,state)
end

function BaseGameModel:HasCardCellGift(card_id,cell_index)
    return this.roundData:HasCardCellGift(card_id,cell_index)
end

--是否已经签名过,使用格子数字
function BaseGameModel:IsSigned(cardid, num)
    return this.roundData:IsSigned(cardid,num)
end

--是否已经签名过,使用索引
function BaseGameModel:CanSignByIndex(cardid, index)
    return this.roundData:CanSignByIndex(cardid,index)
end

--开启放大镜
function BaseGameModel:SetMirror2(cardid, index)
    this.roundData:SetMirror2(cardid, index)
end

-- 格子是否正在闪烁
function BaseGameModel:IsMirror2(cardid, index)
    return this.roundData:IsMirror2(cardid, index)
end


-----------------settle---------------------------------------------------------------------------------------------------------------

function BaseGameModel:GetSettleCode()
    return this.settleCode
end

function BaseGameModel:ResetSettleCode()
    this.settleCode = 0
end

function BaseGameModel:SaveSortRocketExtraPosInfo()
    if this.settle.cardRocket then
        this.sortedRocketExtraPos = {}
        for i = 1, #this.settle.cardRocket do
            if this.settle.cardRocket[i].extraPos then
                this.sortedRocketExtraPos[this.settle.cardRocket[i].cardId] = {}
                for m = 1, #this.settle.cardRocket[i].extraPos do
                    table.insert(this.sortedRocketExtraPos[this.settle.cardRocket[i].cardId], tostring(this.settle.cardRocket[i].extraPos[m])  )
                end
            end
        end
    end
    if this.settle.cardRocket2 then
        this.sortedRocketExtraPos2 = {}
        for i = 1, #this.settle.cardRocket2 do
            if this.settle.cardRocket2[i].extraPos then
                this.sortedRocketExtraPos2[this.settle.cardRocket2[i].cardId] = {}
                for m = 1, #this.settle.cardRocket2[i].extraPos do
                    table.insert(this.sortedRocketExtraPos2[this.settle.cardRocket2[i].cardId], tostring(this.settle.cardRocket2[i].extraPos[m] ))
                end
            end
        end
    end
end

function BaseGameModel:SaveSettleData(data, code)
    Event.Brocast(EventName.Recorder_Data, 5008, { code = code, data = data })
    this.settleCode = code
    self:InitSettleExtraInfo(data)
    --if this.settle and this.settle.cardRocket then
    --    local extra = deep_copy(this.settle.cardRocket) --要深度复制不然
    --    local extra2 =nil
    --    if this.settle.cardRocket2 then  --没有火箭1 就没有火箭2 
    --        extra2 = deep_copy(this.settle.cardRocket2) --要深度复制不然
    --    end
    --    this.settle = data
    --    this.settle.cardRocket = extra
    --    this.settle.cardRocket2 = extra2
    --    --self:SaveSortRocketExtraPosInfo()
    --else
        this.settle = data
        --self:SaveSortRocketExtraPosInfo()
    --end
    --if data.rocketAddItemPos and #data.rocketAddItemPos >0 then
    --    for i = 1, #data.rocketAddItemPos do
    --        local cardId = data.rocketAddItemPos[i].cardId
    --        for ki = 1, #data.rocketAddItemPos[i].cardMarkedPos do
    --            local pos = ConvertServerPos(data.rocketAddItemPos[i].cardMarkedPos[ki].pos)
    --            for m = 1, #data.rocketAddItemPos[i].cardMarkedPos[ki].itemReward do
    --                local itemInfo = data.rocketAddItemPos[i].cardMarkedPos[ki].itemReward[m]
    --                self:GetRoundData(cardId,pos):AddHideGift(itemInfo)
    --            end
    --        end
    --    end
    --end
end

--获取当前卡牌套数
function BaseGameModel:GetSettleData()
    return this.settle
end

--- 小火箭界面随机盖章，需要从结算数据中获取盖章位置
function BaseGameModel:GetRocketExtraPosData(cardId, cellIndex)
    if this.game_type == PLAY_TYPE.PLAY_TYPE_THREE_PIGS then
        return self:GetRocketExtraPosDataNew(cardId, cellIndex)
    end

    local serverPos = tostring(ConvertCellIndexToServerPos(cellIndex))
    if ModelList.BattleModel:GetGameState() == GameState.RocketBlast1 and this.sortedRocketExtraPos and this.sortedRocketExtraPos[cardId] then
        for i = 1, #this.sortedRocketExtraPos[cardId] do
            if fun.starts(this.sortedRocketExtraPos[cardId][i], serverPos) then
                return this.sortedRocketExtraPos[cardId][i]
            end
        end
    elseif ModelList.BattleModel:GetGameState() == GameState.RocketBlast2 and this.sortedRocketExtraPos2 and this.sortedRocketExtraPos2[cardId] then
        for i = 1, #this.sortedRocketExtraPos2[cardId] do
            if fun.starts(this.sortedRocketExtraPos2[cardId][i], serverPos) then
                return this.sortedRocketExtraPos2[cardId][i]
            end
        end
    end
    return nil
end

function BaseGameModel:GetRocketExtraPosDataNew(cardId, cellIndex)
    local serverPos = tostring(ConvertCellIndexToServerPos(cellIndex))
    if ModelList.BattleModel:GetGameState() == GameState.RocketBlast1 and this.sortedRocketExtraPos and this.sortedRocketExtraPos[cardId] then
        for i = 1, #this.sortedRocketExtraPos[cardId] do
            if fun.starts(this.sortedRocketExtraPos[cardId][i], serverPos) and string.len(this.sortedRocketExtraPos[cardId][i]) > 2 then
                return this.sortedRocketExtraPos[cardId][i]
            end
        end
    elseif ModelList.BattleModel:GetGameState() == GameState.RocketBlast2 and this.sortedRocketExtraPos2 and this.sortedRocketExtraPos2[cardId] then
        for i = 1, #this.sortedRocketExtraPos2[cardId] do
            if fun.starts(this.sortedRocketExtraPos2[cardId][i], serverPos) and string.len(this.sortedRocketExtraPos2[cardId][i]) > 2 then
                return this.sortedRocketExtraPos2[cardId][i]
            end
        end
    end
    return nil
end

function BaseGameModel:InitSettleExtraInfo(data)
    if data and not fun.is_empty_str(data.extra) then
        self.settle_extra_data = JsonToTable(data.extra)
    end
end

function BaseGameModel:GetSettleExtraInfo(typeName, params)
    if self.settle_extra_data and self.settle_extra_data[typeName] then
        if params and self.settle_extra_data[typeName][params] then
            return self.settle_extra_data[typeName][params]
        else
            return self.settle_extra_data[typeName]
        end
    end
    return
end

-----------------战斗结算流程--------------------------------------------------------------------------------------------------------
this.waitUpFinnalRes = nil
function BaseGameModel:CancelLoopUpFinnalInfo()
    if this.waitUpFinnalRes ~= nil then
        LuaTimer:Remove(this.waitUpFinnalRes)
        this.waitUpFinnalRes = nil
        log.log("BaseGameModel.CancelLoopUpFinnalInfo succ ")
    end
end

--收到后端游戏结算消息
function BaseGameModel.ResUploadFinalInfo(code, data)
    log.log("BaseGameModel.ResUploadFinalInfo code is ", code)
    this:CancelLoopUpFinnalInfo()
    if (code == RET.RET_SUCCESS) then
        SDK.upload_settle_data("upload_settle_data_success")
        ModelList.BingopassModel:RecordBettleRound()
            
        local checkMsg = {
            [MSG_ID.MSG_GAME_COMMON_PRE_SETTLE] = false, 
            [MSG_ID.MSG_GAME_COMMON_SETTLE] = false,
        }
        --附带其它-推送协议
        table.each(data and data.nextMessages, function(v)
            local body = Base64.decode(v.msgBase64)
            local ret = Proto.decode(v.msgId, body)
            Message.DispatchMessage(v.msgId, v.code, ret)
            if checkMsg[v.msgId] ~= nil then
                checkMsg[v.msgId] = v.code == RET.RET_SUCCESS
            end
        end)
        --local flag = false
        --table.each(checkMsg, function(v)
        --    flag = flag or v
        --end)
        --如果里面没有5306也没有5307  主动请求4070 
        --if not flag then
        --    this:ReqFetchSettle()
        --end
    elseif code == RET.RET_GAME_NOT_EXIST then
        SDK.upload_settle_data("upload_settle_data_fail_no_game")
        UIUtil.return_to_scenehome()
        UIUtil.show_common_global_popup(8011, true)
    else
        --UIUtil.return_to_scenehome()
        SDK.upload_settle_data("upload_settle_data_fail_other")
    end
    
    fun.SafeCall(this.UploadGameDataCb)
    this.UploadGameDataCb = nil
end

--请求游戏结束
function BaseGameModel:ReqQuitBingoGame(pre_quit, gameType, isJackpotPreQuit, cb)
    gameType = gameType or self.game_type
    this:SetReadyState(2)
    
    if pre_quit then
        self:UploadGameData(gameType, GameQuitType.PreQuit, cb)
        this:SetReadyState(4)
    else
        if this:GetReadyState() <= 2 then
            self:UploadGameData(gameType, GameQuitType.Normal, cb)
        end
    end
end

--- 战斗结算前，检查彩球叫号器
function BaseGameModel:CheckJokerBallSprayer(callBack)
    bingoJokerMachine:CheckJokerBallSprayer(callBack)
end

---@params quiteType   GameQuitType
function BaseGameModel:UploadGameData(gameType, quiteType, cb)
    if this.roundData == nil or this.roundData.GetRoundData== nil then
        --数据问题
        this:CancelLoopUpFinnalInfo()
        return fun.SafeCall(cb)
    end
    local settleData = this:GetSettleData()
    if settleData and this.game_data_ready_state >= 3 then
        this:CancelLoopUpFinnalInfo()
        return fun.SafeCall(cb)
    end

    this.UploadGameDataCb = cb
    
    local gaid = this:LoadGameData().gameId
    local cardInfo = this.uploadData:PackFinalCardInfo(this.roundData:GetRoundData())
    local robotData = this.uploadData:GetRobotsOrder()
    local calledNumbers = this.totalNumber
    local powerUpNo = this.view.powerView:GetUsedUpCount()
    local fastMarked = this.uploadData:GetFastClickInfo()
    local city_play_id = ModelList.CityModel.GetPlayIdByCity()
    --log.r("结算 play id  == " .. city_play_id)
    local ext = this.uploadData:GetExtInfo(this.roundData:GetRoundData())
    ext = self:UpdateUpLoadDataExt(ext)
    local info = { 
        gameId = gaid, 
        --playType = gameType, 
        cardInfo = cardInfo, 
        --robotData = robotData, 
        settleType = quiteType,
        calledNumbers = calledNumbers, 
        --powerUpNo = powerUpNo, 
        --fastMarked = fastMarked,
        --playId = city_play_id, 
        extra = ext
    }
    if fun.IsEditor() then
        if BingoBangEntry.IsReplayBattle then
            --Event.Brocast(EventName.Event_stop_bingo_game)
            this:SetReadyState(2)
            ModelList.GMModel:AutoReplaySettle()
            return
        else
            this.SendMessage(MsgIDDefine.PB_BingoGameReportData, info, true);
        end
    else
        this.SendMessage(MsgIDDefine.PB_BingoGameReportData, info, true);
    end
    SDK.upload_settle_data("upload_settle_data")
    Event.Brocast(EventName.Event_Upload_Game_Settle_Data)
    if this.waitUpFinnalRes == nil then
        this.waitUpFinnalRes = LuaTimer:SetDelayLoopFunction(5, 5, -1, function()
            self:UploadGameData(gameType, quiteType, cb)
        end,nil, nil,LuaTimer.TimerType.Battle)
    end
    --this:StopBattleMachine()
end

function BaseGameModel:ShowSettle(need_reduce)
    if this:GetGameState() < GameState.ShowSettle then
        this:SetGameState(GameState.ShowSettle)
    end
end

function BaseGameModel:PlayBattleOverSound()
    UISound.play("battleover")
end

function BaseGameModel.ReqFetchSettle()
    if this:LoadGameData() then
        this.SendMessage(MSG_ID.MSG_FETCH_SETTLE_DATA, { gameId = this:LoadGameData().gameId, playType = this.game_type });
    end
end

---@see 保存结算卡牌完成点击情况
function BaseGameModel:SavePerfectInfo(cardId,isPerfect)
    if not this.perfectInfo  then
        this.perfectInfo={}
    end
    this.perfectInfo[cardId] = isPerfect
end

---@see 获取结算卡牌完成点击情况
function BaseGameModel:GetPerfectInfo(cardId)
    cardId = tonumber(cardId)
    if not this.perfectInfo  or  not this.perfectInfo[cardId] then
        return false
    end
    return this.perfectInfo[cardId]
end

--- 结算自身是否排名前3
function BaseGameModel:IsSettleRankBeforeThree()
    if this.settle.ranks[1].nickName  =="0" or this.settle.ranks[2].nickName  =="0" or this.settle.ranks[3].nickName  =="0" then
        return true
    else
        return false
    end
end

--请求使用power up
function BaseGameModel.ReqUsePowerUp(index, powerUpId, cb)
    if BingoBangEntry.IsReplayBattle then
        return
    end

    this.ReqUsePowerUpCb = cb
        
    local gameId = this:LoadGameData().gameId
    this.SendMessage(MsgIDDefine.PB_BingoGameUsePowerUp, {
        gameId = tostring(gameId),
        pIndex = tonumber(index),
        powerUpId = tonumber(powerUpId),
    })
    --this.SendMessage(MSG_ID.MSG_GAME_POWERUP, {gameId = gaid,id = index,extra = extra_info,index = curr_index});
end

function BaseGameModel.RespondUsePowerUp(code,data)
    log.r("[BaseGameModel] RespondUsePowerUp data:", data)
    if code == RET.RET_SUCCESS then
        fun.SafeCall(this.ReqUsePowerUpCb, true)
    else
        fun.SafeCall(this.ReqUsePowerUpCb, false)
    end
    this.ReqUsePowerUpCb = nil
end

--小火箭界面再次结算，获取到新结算数据
function BaseGameModel:IsGetNewSettleData()
    return this:GetReadyState() == 5
end

function BaseGameModel:OnReceiveSettle()

end

-----------------Other---------------------------------------------------------------------------------------------------------------------------

--确认bingo场景加载完成，通知后端开始叫号
function BaseGameModel:ReqGameReady()
    this.StartBattleMachine()
    BattleModuleList.EnableUpdate()
    Event.Brocast(EventName.Recorder_Data,5002,nil)
end

---  开启战斗所需要的的机器
--准备战斗需要的，叫号机
function BaseGameModel.StartBattleMachine()
    BattleMachineList.StartBattleMachine()
end

--准备结束停止机器，叫号机
function BaseGameModel.StopBattleMachine()
    BattleMachineList.StopBattleMachine()
end

function BaseGameModel.PauseBattleMachine(isPause)
    BattleMachineList.PauseBattleMachine(isPause)
    CallNumberMachine:Pause(isPause)
    CalculateBingoMachine.Pause(isPause)
    BingoLeftTickMachine:Pause(isPause)
end

function BaseGameModel:GetCallNumberInterval()
    return CallNumberMachine:GetInterval()
end

function BaseGameModel:CalcuateBingo(tCardId, index, options)
    CalculateBingoMachine.CalcuateBingo(tCardId, index, options)
end

function BaseGameModel:CalculateJackpot2(tCardId, index)
    CalculateBingoMachine.CalculateJackpot2(tCardId, index)
end

--选择的城市是否已经开启
function BaseGameModel:CheckCityIsOpen()
    --local city = ModelList.CityModel:GetCity()
    --local limit = Csv.GetData("city", city,"openlevel")
    --if ModelList.PlayerInfoModel:GetLevel() < limit then
    --    UIUtil.show_common_error_popup(8023,true,nil)
    --    return false
    --end
    
    return true
end

function BaseGameModel:GetQuestItemScale()
    return 1
end

---赛车活动 玩法卡面上油桶道具与格子的相对位置
function BaseGameModel:GetQuestItemOffsetPos(itemId)
    local itemType = Csv.GetItemOrResource(itemId, "item_type")
    if itemType == 33 then
        --火山活动道具
        return 40, -42
    end
    
    return 35, -26
end

--音符道具大小
function BaseGameModel:GetWinZoneItemScale()
    return 0.9
end

--音符道具投放位置
function BaseGameModel:GetWinZoneItemOffsetPos()
    return -39.5, 34.5
end

---向4066的ext字段添加额外的数据，自定义不同的玩法需要添加的数据
---ext是json类型，需要做转换
function BaseGameModel:UpdateUpLoadDataExt(ext)
    if this.matchChargeRewardIdList and #this.matchChargeRewardIdList > 0 then
        ext = JsonToTable(ext)
        ext.markAccReward = this.matchChargeRewardIdList
        ext = TableToJson(ext)
    end

    return ext
end

---是否展示普通格子可以达成Bingo时的wish状态
function BaseGameModel:CanShowNormalCellBingoWish()
    return true
end

---是否展示普通格子可以达成Jackpot时的wish状态
function BaseGameModel:CanShowNormalCellJackpotWish()
    return true
end

---是否展示技能格子可以达成Bingo/Jackpot时的wish状态
function BaseGameModel:CanShowSkillCellWish()
    return true
end

---Bingo规则差n个格子就达成了bingo,展示这n个格子的wishState
function BaseGameModel:GetLessAchievedBingoNeedCount()
    return 1
end

---Jackpot规则差n个格子就达成了Jackpot,展示这n个格子的wishState
function BaseGameModel:GetLessAchievedJackpotNeedCount()
    return 1
end

---4066上传数据时检查是否有效
function BaseGameModel:CheckHideGiftUpload(cellData, itemID)
    return true
end

function BaseGameModel:CollectMatchChargeReward(matchChargeRewardId)
    if not this.matchChargeRewardIdList then
        this.matchChargeRewardIdList = {}
    end
    table.insert(this.matchChargeRewardIdList, matchChargeRewardId)
end

--- 部分玩法带有小游戏数据,
function BaseGameModel:GetSmallGameData()
    return nil
end

--- 部分玩法带有小游戏数据,
function BaseGameModel.ResponeBallShaker(code, data)

end
--- 部分玩法带有小游戏数据,
function BaseGameModel.ResponeBallShakerResult(code, data)

end
--- 部分玩法带有小游戏数据,
function BaseGameModel.ResponeMansionInfo(code, data)

end

---------------------BingoBang Start---------------------

function BaseGameModel:ReqEnterGame(cb)
    self.reqEnterGameCb = cb

    if not self:CheckCityIsOpen() then
        fun.SafeCall(cb, false)
        return
    end
    
    ModelList.BattleModel:SetGameType(self.game_type)
    ModelList.CityModel.SetPlayId(self.game_type)
    self:SetReadyState(0)

    local cardNum = ModelList.CityModel:GetCardNumber()
    local betRate = ModelList.CityModel:GetBetRate()
    local powerupGear,powerupId = ModelList.CityModel:GetPowerupGear()
    local city = ModelList.CityModel:GetCity()
    local coupon = ModelList.CouponModel.get_currentCouponIdByCardNum(cardNum)
    local useId = ModelList.CouponModel.get_currentCouponUseIdByCardNum(cardNum)
    ModelList.CityModel:SavePreviousPlayInfo()
    this:ResetSettleCode()
    local hideCardAuto = ModelList.BattleModel.GetIsAutoSign() and 1 or 0

    if BingoBangEntry.IsReplayBattle then
        --测试战斗
        return
    end

    this.SendMessage(MsgIDDefine.PB_BingoGameLoad, {
        cardNum = cardNum,
        rate = betRate,
        --powerUpId = tonumber(powerupId),
        --cityId = city,
        couponId = coupon,
        --useCouponId = useId,
        playId = ModelList.CityModel.GetPlayIdByCity(),
        hideCardAuto = hideCardAuto,
        sceneId = ModelList.CityModel:GetCity(),
    })

    --this:InitBattleMessageQueue()
end

--收到进入游戏返回，允许进入Game场景
function BaseGameModel.RespondEnterGame(code,data)
    ModelList.BattleModel:ResEnterGame(code,data)
end

function BaseGameModel:ResEnterGame(code,data)
    if code == RET.RET_SUCCESS then
        self:SaveGameLoadData(data)
        self:SetReadyState(1)
        self:InitRoundData()
        self:InitExtraData(data.extra)

        --sgDataComp:Init()
        --ModelList.BattleModel.UpdateBattleSuperMatchToggle()

        ModelList.BattleModel.SetBattleDouble(data.activityStatus)
        ModelList.BattleModel.SetIsJokerMachine(false)
        ModelList.BattleModel:BackupLoadData(data)
        --Event.Brocast(EventName.Event_enter_bingogame)
        self:SetGameState(GameState.Ready)
        Event.Brocast(EventName.Recorder_Data,5001,data)
        fun.SafeCall(self.reqEnterGameCb, true)
    else
        log.r("发送进入游戏失败"..code)
        UIUtil.return_to_scenehome()
        UIUtil.show_common_global_popup(8004,true)
        fun.SafeCall(self.reqEnterGameCb, false)
    end
    self.reqEnterGameCb = nil
end

---结算时是否有LuckyBang
function BaseGameModel:CheckHasLuckyBang()
    local luckyBangData = this.settle and this.settle.luckyBang
    --luckyBangData.numbers = { 13, 21, 35, 42, 54}  --测试用数据
    if luckyBangData and GetTableLength(luckyBangData.numbers) > 0 then
        return true
    else
        return false
    end
end

--卡片是否已经达到bingo上限
function BaseGameModel:CheckIsMaxBingo(cardId)
    local playType = self.game_type
    local playCfg = table.find(Csv["new_city_play"], function(k, v)
        return v.play_type == playType
    end)
    local nowLevel, checkedLevel = ModelList.PlayerInfoModel:GetLevel(), 0
    local curBingoCount = CalculateBingoMachine.GetTotalBingoCount(cardId)
    local needForbidCard, unlockLevel, maxBingoCount = false

    table.walk(playCfg and playCfg.bingo_unlock, function(v)
        local level, maxCount = v[1], v[2]
        if level and maxCount then
            if checkedLevel <= level then
                if nowLevel >= level then
                    checkedLevel = level
                    needForbidCard = curBingoCount >= maxCount
                    maxBingoCount = maxCount
                else
                    unlockLevel = level
                end
            end
        end
    end)

    return needForbidCard, unlockLevel, maxBingoCount or 5
end

function BaseGameModel:CheckEffectShowOver()
    return true
end

function BaseGameModel:GetIsMaxBet()
    local ret = self:GetBattleExtraInfo("useMaxRate")
    return ret
end

function BaseGameModel:HandleBingoDataOnPlayBingo(bingoData)
    local bingo_table = {}
    for i = 1, #bingoData do
        local id = bingoData[i].cardId
        local info_type = bingoData[i].type
        local total_count = bingoData[i].totolCount
        local thRank = bingoData[i].th
        if bingoData[i].numbers then
            for k = 1, #bingoData[i].numbers do
                self:RefreshRoundDataByIndex(id, bingoData[i].numbers[k], bingoData[i].type + 1)
            end
        end
        local mIndex = tostring(id)
        local jackpot_count = 0
        if info_type == 2 then
            jackpot_count = 1
        end
        local cardId_ = tonumber(mIndex)
        if not fun.is_key_include(cardId_, bingo_table) then
            bingo_table[cardId_] = { index = mIndex, bingo = total_count, jackpot = jackpot_count,
                                     first_num = bingoData[i].numbers and bingoData[i].numbers[1] or nil,
                                     th = { thRank }, startCount = total_count,
                                     data = bingoData[i]}
        else
            bingo_table[cardId_].bingo = bingo_table[cardId_].bingo > total_count and bingo_table[id].bingo or total_count
            bingo_table[cardId_].jackpot = bingo_table[cardId_].jackpot + jackpot_count
            if thRank > 0 then
                table.insert(bingo_table[id].th, thRank)
            end
        end
    end
    return bingo_table
end

---------------------BingoBang End--------------------

BaseGameModel.BaseMsgIdList = {
    { msgid = MSG_ID.MSG_UP_FINAL_INFO, func = this.ResUploadFinalInfo },
    { msgid = MsgIDDefine.PB_BingoGameReportData, func = this.ResUploadFinalInfo },
    { msgid = MsgIDDefine.PB_BingoGameLoad, func = this.RespondEnterGame },
    { msgid = MsgIDDefine.PB_BingoGameUsePowerUp, func = this.RespondUsePowerUp },
}

return this
