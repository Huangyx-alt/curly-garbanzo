---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2024/3/4 11:06
---


local BaseShortPassTaskItem = BaseView:New("BaseShortPassTaskItem")
local this = BaseShortPassTaskItem
this.viewType = CanvasSortingOrderManager.LayerType.None

local _taskToggle = nil
--local _taskPoint = nil

this.auto_bind_ui_items = {
    "GoldTask",
    "text_extra",
    "itemParent",
    "btn_collect",
    "img_progress",
    "text_progress",
    "img_gold_tag",
    "TaskContent",
    "rewardDescripe",
    "slider_progress",
    "Lock",
    "item",
    "Gold",
    "TaskComplete",
    "Difficult",
    "Normal",
    "lock_text_extra",
    "points",
    "left_time_txt",
    "img_double1",
    "img_double2",
    "difficult_left_time",
    "difficult_left_time_txt",
    "arrowHead"
}
local n = 0
function BaseShortPassTaskItem:New(longTaskAtlasName)
    local o = {}
    self.__index = self
    self.longTaskAtlasName = longTaskAtlasName
    setmetatable(o, self)
    return o
end

function BaseShortPassTaskItem:SetDifficultTaskLeftTime()
    local expireTime = 0
    if self._taskData and self._taskData.expireTime then
        expireTime = self._taskData.expireTime
    end

    local currentTime = ModelList.PlayerInfoModel.get_cur_server_time()
    self.difficultTaskEndTime = expireTime - currentTime
    self:RemoveDifficultTaskTimer()
    if self.difficultTaskEndTime > 0 then
        self.loopDifficultTaskTimer = LuaTimer:SetDelayLoopFunction(0, 1, -1, function ()
            if fun.is_not_null(self.difficult_left_time_txt) and self.difficultTaskEndTime >= 0 then
                self.difficult_left_time_txt.text = fun.SecondToStrFormat(self.difficultTaskEndTime)
                self.difficultTaskEndTime = self.difficultTaskEndTime - 1
                if self.difficultTaskEndTime <= 0 then
                    --- 倒计时结束，重新请求数据
                    ModelList.GameActivityPassModel.C2S_ForceRequestBingopassDetail(true)
                end
            end
        end)
    end
end

function BaseShortPassTaskItem:RemoveDifficultTaskTimer()
    if self.loopDifficultTaskTimer then
        LuaTimer:Remove(self.loopDifficultTaskTimer)
        self.loopDifficultTaskTimer = nil
    end
end

function BaseShortPassTaskItem:SetParent(parent)
    self.parent = parent
end

function BaseShortPassTaskItem:Awake()
    self:on_init()
end

function BaseShortPassTaskItem:OnEnable()
    self._isinit = true
    --self.text_reward:SetKMB(true)
    --self:SetTaskData(self._taskData, _taskToggle)
    self:RegisterEvent()
end

function BaseShortPassTaskItem:OnDisable()
    _taskToggle = nil
    self._isinit = nil
    self.itemList = nil
    self:ClaimRewardResult()
    self:UnRegisterEvent()
    self:ClearBuffLoopTimer()
    self:RemoveDifficultTaskTimer()
    if self.remainTimeCountDown then
        self.remainTimeCountDown:StopCountDown()
        self.remainTimeCountDown = nil
    end
end

function BaseShortPassTaskItem:GetTransform()
    if self.go then
        return self.go.transform
    end
    return nil
end

function BaseShortPassTaskItem:on_btn_go_click()
    if self._taskData then
        Facade.SendNotification(NotifyName.TaskView.Click_go_button, self._taskData.taskSubType)
    end
end

function BaseShortPassTaskItem:SetTaskData(data, currOrder, taskCityPlayId, onlyOneTask, count, parentView)
    if data then
        self._parentView = parentView
        self._taskData = data
        self.onlyOneTask = onlyOneTask
        self._taskCityPlayId = taskCityPlayId
        self.count = count
        if not self.Rename then
            self.Rename = true
            self.go.name = count
        end
        --log.e("set count  =  count = "..count.."    oriName = "..self.go.name)
        if self._isinit then
            local isDifficultShow = self._taskData.isDifficult or self._taskData.taskType == 6
            fun.set_active(self.Gold, isDifficultShow)
            fun.set_active(self.Difficult, isDifficultShow)
            fun.set_active(self.points, isDifficultShow)
            local extra = fun.find_child(self.TaskComplete, "extra")
            local task_type = Csv.GetData("task", self._taskData.taskId, "task_type")
            if self._taskData.isDifficult or self:IsLongTask(task_type) then
                -- 困难任务，直接开启
                fun.set_active(self.difficult_left_time, true)
                self:SetHardTask()
            else
                Destroy(extra)
                fun.set_active(self.difficult_left_time, false)
                fun.set_active(self.Normal, true)
                --普通任务，判断是否开启
                if self._taskData.order == currOrder or onlyOneTask or
                    (self._taskData.order < currOrder and self._taskData.completed and not self._taskData.rewarded) then
                    fun.set_active(self.points, not onlyOneTask)
                    self:SetNormalTask()
                else
                    self:SetLockTask()
                end
            end
        end
    end
end

function BaseShortPassTaskItem:SetNormalTask()
    fun.set_active(self.Lock, false)
    fun.set_active(self.TaskComplete, false)
    local data = self._taskData
    if self._taskData.rewarded then
        if self.onlyOneTask then
            self:SetTaskComplete()
        end
    else
        -- 未完成
        local task = Csv.GetData("task", data.taskId)
        local des = Csv.GetData("description", task.description)
        local playName = Csv.GetData("city_play", ModelList.GameActivityPassModel.GetCurrentId(), "name")
        local targetStr = string.format(des.description, data.target)

        self.rewardDescripe.text = tostring(targetStr) .. Csv.GetDescription(30120)

        self.slider_progress.value = tonumber(data.process) / tonumber(data.target)
        self.text_progress.text = string.format("%s/%s", data.process, data.target)
        --if (task.task_type == 6 and self._taskCityPlayId == 26 ) then
        if self:IsLongTask(task.task_type) then
            fun.set_active(self.arrowHead, true)
            local iconTable = Csv.GetData("task", self._taskData.taskId, "reward_icon")
            local itemObjCount = fun.get_child_count(self.itemParent)
            for i = 1, itemObjCount do
                Destroy(fun.get_child(self.itemParent, i - 1))
            end
            local gameMode = ModelList.CityModel:GetEnterGameMode()
            local valueChange = nil
            if gameMode == PLAY_TYPE.PLAY_TYPE_HORSE_RACE then
                for i = 1, #self._taskData.reward do
                    if Csv.GetData("item", self._taskData.reward[i].id, "item_type") == 39 then
                        valueChange = { self._taskData.reward[i].value - 1, self._taskData.reward[i].value }
                    end
                end
            end

            for i = 1, 2 do
                local item = fun.get_instance(self.item, self.itemParent)
                fun.set_active(item, true)
                self:ChangeIconSize(item)
                local refItem = fun.get_component(item, fun.REFER)
                local icon = refItem:Get("icon")
                local textNum = refItem:Get("textNum")
                local textCount = refItem:Get("textCount")
                local valueUp = refItem:Get("valueUp")
                local zi = refItem:Get("zi")
                local descriptionId = self:GetIconLevel(iconTable[i])
                zi.text = Csv.GetData("description", descriptionId, "description")
                local bg = refItem:Get("bg")
                icon.sprite = AtlasManager:GetSpriteByName(self.longTaskAtlasName or "ItemAtlas", iconTable[i])
                self:ChangeLongTaskIconSize(icon.gameObject)
                if valueChange and #valueChange == 2 then
                    fun.set_active(textCount, true)
                    textCount.text = "x" .. valueChange[i]
                end
                fun.set_active(textNum, false)
                fun.set_active(bg, true)
                fun.set_active(zi, true)
                if i == 2 then
                    fun.set_active(valueUp, true)
                end
            end
            for i = 1, #self._taskData.reward do
                if self._taskData.reward[i].id == Resource.taskpoint then
                    self.extraValue = self._taskData.reward[i].value
                    self:UpdateExtraValue()
                end
            end
        else
            if self._taskData.isDifficult then
                local itemObjCount = fun.get_child_count(self.itemParent)
                for i = 1, itemObjCount do
                    Destroy(fun.get_child(self.itemParent, i - 1))
                end
                fun.set_active(self.arrowHead, false)
            end
            for i = 1, #self._taskData.reward do
                if self._taskData.reward[i].id ~= Resource.taskpoint then
                    local item = nil
                    if self._taskData.isDifficult then
                        item = fun.get_instance(self.item, self.itemParent)
                    else
                        item = self:GetItemGrid(i, self.item, self.itemParent)
                    end
                    fun.set_active(item, true)
                    self:SetItemGrid(self._taskData.reward[i].id, self._taskData.reward[i].value, item)
                else
                    self.extraValue = self._taskData.reward[i].value
                    self:UpdateExtraValue()
                end
            end
        end

        fun.set_active(self.TaskContent, true)
        fun.set_active(self.btn_collect, self._taskData.completed and true or false)
    end
end

function BaseShortPassTaskItem:GetIconLevel(iconName)
    for i, v in pairs(Csv.item) do
        if v.icon == iconName then
            return v.description
        end
    end
end

function BaseShortPassTaskItem:UpdateExtraValue()
    local value = self.extraValue or 0
    --self.text_extra.text = value --  string.format("x%s", _taskPoint)
    --self.lock_text_extra.text = self._taskData.reward[i].value --  string.format("x%s", _taskPoint)
    local buffLeftTime = self:GetBuffLeftTime()
    log.log("BaseShortPassTaskItem:UpdateExtraValue", buffLeftTime, value)
    if buffLeftTime > 0 then
        self:ShowDoubleBuffFlag()
        self.text_extra.text = value * 2
        self.text_extra.color = Color.New(255 / 255, 239 / 255, 128 / 255, 1)
        self.lock_text_extra.text = value * 2
        self.lock_text_extra.color = Color.New(255 / 255, 239 / 255, 128 / 255, 1)
        self:SetBuffLeftTime(buffLeftTime)
    else
        self:HideDoubleBuffFlag()
        self.text_extra.text = value
        self.text_extra.color = Color.New(1, 1, 1, 1)
        self.lock_text_extra.text = value
        self.lock_text_extra.color = Color.New(1, 1, 1, 1)
    end
end

function BaseShortPassTaskItem:ShowDoubleBuffFlag()
    if fun.is_not_null(self.img_double1) then
        fun.set_active(self.img_double1, true)
    end
    if fun.is_not_null(self.img_double2) then
        fun.set_active(self.img_double2, true)
    end
end

function BaseShortPassTaskItem:HideDoubleBuffFlag()
    if fun.is_not_null(self.img_double1) then
        fun.set_active(self.img_double1, false)
    end

    if fun.is_not_null(self.img_double2) then
        fun.set_active(self.img_double2, false)
    end
end

function BaseShortPassTaskItem:GetBuffLeftTime()
    local buffId = self.parent:GetBuffId()
    if not buffId or buffId == 0 then
        return 0
    end
    local expireTime = ModelList.ItemModel:GetItemNumById(buffId)
    local curTime = ModelList.PlayerInfoModel.get_cur_server_time()
    local remainTime = math.max(0, expireTime - curTime)

    return remainTime
end

function BaseShortPassTaskItem:GetTargetRewards()
    local rewards = deep_copy(self._taskData.reward)
    for i = 1, #rewards do
        if rewards[i].id == Resource.taskpoint then
            if self:GetBuffLeftTime() > 0 then
                rewards[i].value = rewards[i].value * 2
            end
            break
        end
    end

    return rewards
end

function BaseShortPassTaskItem:SetBuffLeftTime(remainTime)
    self.buffLeftTime = remainTime
    self:ClearBuffLoopTimer()
    if self.buffLeftTime > 0 then
        self.buffLoopTimer = LuaTimer:SetDelayLoopFunction(0, 1, -1, function ()
            --[[
            if self.left_time_txt then
                self.left_time_txt.text = fun.SecondToStrFormat(self.buffLeftTime)
            end
            --]]

            self.buffLeftTime = self.buffLeftTime - 1
            if self.buffLeftTime <= 0 then
                self:UpdateExtraValue()
            end
        end, nil, nil, LuaTimer.TimerType.UI)
    end
end

function BaseShortPassTaskItem:ClearBuffLoopTimer()
    if self.buffLoopTimer then
        LuaTimer:Remove(self.buffLoopTimer)
        self.buffLoopTimer = nil
    end
end

function BaseShortPassTaskItem:OnItemsChange(params)
    --Event.Brocast(EventName.Event_items_change,{items = value, type = key})
    if not params then
        return
    end

    if params.type == 31 then --ITEMS_TYPE.ITEMS_TYPE_SPECIAL_GAME_BUFF
        self:UpdateExtraValue()
    end
end

function BaseShortPassTaskItem:SetTaskComplete()
    self:SetLeftTime(self._taskData.expireTime)
    fun.set_active(self.TaskComplete, true)
    fun.set_active(self.TaskContent, false)
    fun.set_active(self.btn_collect, false)
end

function BaseShortPassTaskItem:SetLeftTime(endTimeStamp)
    local endTime = math.max(0, endTimeStamp - ModelList.PlayerInfoModel.get_cur_server_time())
    if not self.remainTimeCountDown then
        self.remainTimeCountDown = RemainTimeCountDown:New()
    end
    self.remainTimeCountDown:StartCountDown(CountDownType.cdt2, endTime, self.left_time_txt, function ()
        if self then
            --- 倒计时结束，重新请求数据
        end
    end)
end

function BaseShortPassTaskItem:SetLockTask()
    fun.set_active(self.TaskContent, false)
    fun.set_active(self.TaskComplete, false)
    for i = 1, #self._taskData.reward do
        if self._taskData.reward[i].id == Resource.taskpoint then
            self.extraValue = self._taskData.reward[i].value
            self:UpdateExtraValue()
            break
        end
    end
    fun.set_active(self.Lock, true)
end

function BaseShortPassTaskItem:SetHardTask()
    if self._taskData.rewarded then
        self:SetTaskComplete()
        fun.set_active(self.difficult_left_time, false)
        self:RemoveDifficultTaskTimer()
    else
        self:SetNormalTask()
        self:SetDifficultTaskLeftTime()
    end
end

function BaseShortPassTaskItem:GetItemGrid(index, prefab, parent)
    if self.itemList and self.itemList[index] then
        return self.itemList[index]
    end
    if not self.itemList then
        self.itemList = {}
    end
    local itemGrid = fun.get_instance(prefab, parent)
    self.itemList[index] = itemGrid
    return itemGrid
end

function BaseShortPassTaskItem:SetItemGrid(itemId, itemNum, itemGrid)
    local refItem = fun.get_component(itemGrid, fun.REFER)
    local icon = refItem:Get("icon")
    local textNum = refItem:Get("textNum")
    local iconName = Csv.GetItemOrResource(itemId, "more_icon")
    icon.sprite = AtlasManager:GetSpriteByName("ItemAtlas", iconName)
    textNum.text = fun.format_money_reward({ id = itemId, value = itemNum })
end

function BaseShortPassTaskItem:on_btn_collect_click()
    if self._parentView:IsRewarding() then
        return
    end
    if self._taskData then
        log.log("BaseShortPassTaskItem:on_btn_collect_click ", self._taskData.reward)
        self._waitReward = true
        self:AddEvent()
        Facade.SendNotification(NotifyName.ClaimReward.PopupClaimReward, PopupViewType.show,
            ClaimRewardViewType.CollectReward, self:GetTargetRewards(), function ()
            local data = { {
                taskType = 7,
                taskGroup = self._taskData.taskGroup,
                taskId = self._taskData.taskId,
                createTime = self._taskData.createTime
                ,
                playId = self._taskCityPlayId
            } }
            ModelList.TaskModel.C2S_SubmitTask(data)
        end)
    end
end

--function BaseShortPassTaskItem:ClaimRewardResult()
--    if self._waitReward then--加个waitReward开关，要不领取最后一个任务时会先走OnDisable移除掉事件就无法接收到通知了
--        self._waitReward = nil
--        self:RemoveEvent()
--        Facade.SendNotification(NotifyName.ClaimReward.PopupClaimReward,PopupViewType.hide,ClaimRewardViewType.CollectReward)
--    end
--end


function BaseShortPassTaskItem:ClaimRewardResult()
    if self._waitReward then
        --加个waitReward开关，要不领取最后一个任务时会先走OnDisable移除掉事件就无法接收到通知了
        self._waitReward = nil
        self:RemoveEvent()
        self._parentView:SetRewarding(true)
        Facade.SendNotification(NotifyName.ClaimReward.PopupClaimReward, PopupViewType.hide,
            ClaimRewardViewType.CollectReward)

        --for i = 1, #self._taskData.reward do
        --    local item = self:GetItemGrid(i, self.item, self.itemParent)
        --    fun.set_active(item, true)
        --    self:SetItemGrid(self._taskData.reward[i].id, self._taskData.reward[i].value, item)
        --    Facade.SendNotification(NotifyName.ShopView.FlyRewardEffcts,item.transform.position(),self._taskData.reward[i].id,function()
        --        Event.Brocast(EventName.Event_currency_change)
        --        AddLockCountOneStep(false)
        --        Event.Brocast(EventName.Event_PassGetTaskRewardSucceed)
        --    end)
        --end
    end
end

function BaseShortPassTaskItem:AddEvent()
    Event.AddListener(EventName.Event_GetTaskRewardSucceed, self.ClaimRewardResult, self)
end

function BaseShortPassTaskItem:RemoveEvent()
    Event.RemoveListener(EventName.Event_GetTaskRewardSucceed, self.ClaimRewardResult, self)
end

function BaseShortPassTaskItem:RegisterEvent()
    Event.AddListener(EventName.Event_items_change, self.OnItemsChange, self)
end

function BaseShortPassTaskItem:UnRegisterEvent()
    Event.RemoveListener(EventName.Event_items_change, self.OnItemsChange, self)
end

function BaseShortPassTaskItem:IsLongTask(task_type)
    --- flag:短令牌 每次增加新的短令牌都要修改
    return (task_type == 6 and (self._taskCityPlayId == 26
            or self._taskCityPlayId == 23
            or self._taskCityPlayId == 27
            or self._taskCityPlayId == 28
            or self._taskCityPlayId == 29
            or self._taskCityPlayId == 30
            or self._taskCityPlayId == 31
            or self._taskCityPlayId == 32
            or self._taskCityPlayId == 33
            or self._taskCityPlayId == 35
        )
        )
        and true or false
end

function BaseShortPassTaskItem:ChangeIconSize(item)
    if ModelList.CityModel.GetCurPlayType() == PLAY_TYPE.PLAY_TYPE_SCRATCH_WINNER then
        if fun.is_not_null(item) then
            fun.set_gameobject_scale(item, 0.8, 0.8, 1)
            fun.set_rect_local_pos(item.transform.parent, -2.45, 76, 0)
        end
    end
end

function BaseShortPassTaskItem:ChangeLongTaskIconSize(item)
    if self.scale then
        fun.set_gameobject_scale(item, self.scale.x, self.scale.y, 1)
    end
end

---设置长线任务的ICON大小,因为美术出子令牌图标准不一
function BaseShortPassTaskItem:SetIconSize(scale)
    if scale then
        self.scale = scale
    end
end

---保留此接口给将来扩展,当前不需要 [2025-01-16]
function BaseShortPassTaskItem:SetIconPos(pos)
    if pos then
        --self.scale = scale
    end
end

return this
