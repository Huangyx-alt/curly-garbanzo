---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2022/2/23 20:36
---
---叫号机
---
require("Combat/BaseMachine")
require("Combat/Machine/CalculateBingoMachine")
require("Combat/BaseMachine")

---@class CallNumberMachine  :   BaseMachine
CallNumberMachine = BaseMachine:New("CallNumberMachine")
local this = CallNumberMachine

this.playingTime = 0     -- 游戏叫号时间，暂停后，停止计时
this.callCd = 1
this.playingScaleTime = 1  -- 按callCd 等比例缩放后的时间
this.realPlayingTime = 0     --
this.callCount = 0                --已叫号数量
this.timing = 0                     --开始快速点击的time点
this.IsCallingNumber  = false  --是否正叫号(有时叫号结束，但bingosleft未结束)
this.needPreCheckCall = false   --叫号过后，允许计算一次下一个号能否形成Bingo
this.fastMarkedList = {}                --  快速盖章列表
this.fastMarkedListWithCardId ={}    --带caidId的快速盖章泪飙
this.powerUpData = nil                      -- 所有up卡得使用信息
this.forbidCallNumber ={}                  -- 禁止叫号列表(被up卡占用的号码)
this.mixCallNumbers = {}                    -- 混淆号,不会被叫的号码集合

local CallAcceleration = 10                 -- 追赶真实时间进度的系数
local IsAccelerateTime = false             -- 是否正在追赶正常时间进度
local fastClickTime = 3                        -- 快速点击时间
local lastNumber = 0
local isPause = false

function CallNumberMachine:New()
    local o = {}
    setmetatable(o, { __index = CallNumberMachine });
    return o
end

local SwapValue = function(tTable, source, target)
    local sourceValue = tTable[source]
    local targetValue = tTable[target]
    tTable[source] = targetValue
    tTable[target] = sourceValue
end

---126技能，空盖章格子的情况，排除掉这些格子的号码
local function GetForbidCall()
    --if this.powerUpData then
    --    for k, v in pairs(this.powerUpData) do
    --        if v.powerUpId == 126 then
    --            for i = 1,# v.cardEffect do
    --                if  #v.cardEffect[i].extraPos ==0 then
    --                    local posList = BattleTool.GetFromServerPos(v.cardEffect[i].posList)
    --                    for m = 1, #posList do
    --                        local cellInfo = this.model:GetRoundData(tostring(v.cardEffect[i].cardId), posList[m])
    --                        table.insert(this.forbidCallNumber,cellInfo.num)
    --                    end
    --                end
    --            end
    --        end
    --    end
    --end
end

--- 检查下一个叫号，是否被up卡占用
local CheckNextNumber = function()
    local callNumber = this.numList[1]
    local allPowerNumber = {}
    local tempDoubleNumber = {}  --要考虑双数字影响后面的up卡
    
    table.walk(this.powerUpData and this.powerUpData.powerUpList, function(v)
        if v.isUsed then
            return
        end
        table.walk(v.cardEffect, function(v1)
            local cardId, effectData = v1.cardId, v1.effectData
            tempDoubleNumber[cardId] = tempDoubleNumber[cardId] or {}
            
            --local posList, posList2 = BattleTool.GetFromServerPos(effectData.posList), {}
            local posList, posList2 = effectData.posList, {}
            ---忽略extraPos【可以提前被盖章】【部分玩法有特殊逻辑根据玩法自行添加-比如绿头人extraPos已全部被盖，会切换到其它材料关联坐标集合】
            --if v.basePosType  and v.basePosType ~= 7 then
            --    posList2 = BattleTool.GetFromServerPos(effectData.extraPos)
            --end
            --if #posList2 >0 then fun.add_table(posList,posList2) end
            
            local extra = JsonToTable(effectData.extra or "")
            local doubleNumberList = extra.numbers or {}
            table.walk(posList, function(pos)
                local clientPos = ConvertServerPos(pos)
                local cellInfo = this.model:GetRoundData(tostring(cardId), clientPos)
                if tempDoubleNumber[cardId] then
                    table.walk(tempDoubleNumber[cardId] or {}, function(v2, cardId)
                        if v2.pos == pos then
                            v2.repeatePos = true
                            log.r("有重复up卡位置的   " .. pos .. "  cardid  " .. cardId)
                        end
                    end)
                end
                if GetTableLength(doubleNumberList) > 0 then
                    local temp = table.find(doubleNumberList, function(k3, v3)
                        return v3.pos == pos
                    end)
                    --双数字要判断是否会被盖章
                    if temp and temp.number == callNumber then
                        table.insert(tempDoubleNumber[cardId], { num = cellInfo.num, pos = pos, repeatePos = false })
                    elseif cellInfo then
                        table.insert(allPowerNumber, cellInfo.num)
                    end
                elseif cellInfo and cellInfo.sign == 0 then
                    table.insert(allPowerNumber, cellInfo.num)
                end
            end)
        end)
    end)
    table.walk(tempDoubleNumber, function(v, cardId)
        table.walk(v, function(v2)
            if v2.repeatePos then
                table.insert(allPowerNumber, v2.num)
            end
        end)
    end)
    --local content = BattleTool.PrintList(allPowerNumber)
    --if content ~= "" then
    --    log.r("allNumber  ==" ..content)
    --end
    local FindValue = false
    if table.keyof(allPowerNumber, callNumber) then
        for i = 2, #this.numList do
            if not table.keyof(allPowerNumber, this.numList[i]) then
                log.r("交换两个叫号的顺序 " .. this.numList[1] .. "      " .. this.numList[i])
                SwapValue(this.numList, 1, i)
                FindValue = true
                break
            end
        end
    else
        FindValue = true
    end
    --找混淆号码
    if not FindValue then
        local mixNums = {}
        table.walk(this.mixCallNumbers, function(num)
            if not fun.is_include(num, allPowerNumber) and not CalculateBingoMachine.PreCalculateBingo(num) then
                table.insert(mixNums, num)
            end
        end)

        if #mixNums == 0 then
            log.r("没号可用了 ")
            --找一个既不在叫号列表 又不在up卡列表的号
            for i = 1, 75 do
                if not fun.is_include(i, allPowerNumber) and not fun.is_include(i, this.model:GetCalledNumber()) and
                        not fun.is_include(i, this.mixCallNumbers) and not fun.is_include(i,this.forbidCallNumber)  and
                        not CalculateBingoMachine.PreCalculateBingo(i) then
                    log.r("插入一个空闲的号  " .. i)
                    table.insert(this.numList, 1, i)
                    return
                end
            end

        else
            --混淆号码随机选一个
            local index = math.random(1, #mixNums)
            log.r("找混淆号码, " .. this.numList[1] .. "      替换成   " .. mixNums[index])
            this.numList[1] = mixNums[index]
            FindValue = true
            fun.remove_table_item(this.mixCallNumbers, mixNums[index])
        end
    end

    if FindValue then

    else
        log.r("there no find value, try to find miss point")
        Event.Brocast(EventName.CardPower_FindMissPos)
    end

end

local CreateCallInfo = function()
    if #this.numList > 0 then
        local isBingo = CalculateBingoMachine.PreCalculateBingo(this.numList[1])
        local data = { currNumber = this.numList[1], bingo = isBingo }
        lastNumber = this.numList[1]
        table.remove(this.numList, 1)
        --log.g("叫号: " .. data.currNumber .. "    bingo " .. tostring(data.bingo))
        this.callCount = this.callCount + 1
        --- 是否命中super match 机器人的卡面数字
        data.isSuperMatch = this.CheckSuperMatchNumber()
        if this.gameType == PLAY_TYPE.PLAY_TYPE_AUTO_TICKET then
            Message.DispatchMessage(MSG_ID.MSG_HANGUP_SYNC_NUMBER, 0, data)
        else
            Message.DispatchMessage(MSG_ID.MSG_GAME_SYNC_NUMBER, 0, data)
        end
        ModelList.GuideModel:CallNumber(lastNumber)
        this.ResetFastMarkTime()
        this.IsCallingNumber = true


    else
        log.r("叫号已经完成!!!, 停止叫号")
        this:Stop()
    end

    --[[
    @desc:在第一个号和第9个号的时候,向服务器发送叫号的消息
    author:nuts
    time: 2024-05-22 11:21
    @return:
]]
    --if this.callCount == 1 or this.callCount == 9 then
    if not BingoBangEntry.IsReplayBattle then
        ModelList.GameModel:ReqSyncCallNumberProgress(this.callCount)
    end
    --end
end


--- super match 玩家对机器人的盖章
function CallNumberMachine:CheckSuperMatchNumber()
    if this.isSuperMatch then
        return this.superMatchMachine:CheckSuperMatchNumber(this.callCount, lastNumber)
    end
    return false
end

function CallNumberMachine:Start(loadData)
    this.model = ModelList.BattleModel:GetCurrModel()
    this.numList = deep_copy(loadData.publishNumbers)
    this.mixCallNumbers = loadData.mixCallNumbers
    this.powerUpData = loadData.powerUpData
    this.forbidCallNumber ={}
    fastClickTime = Csv.GetData("control", 77, "content")[1][1] * 0.001
    this.callCd = loadData.callCd
    this:GetDefaultCallCD()
    this.playingTime = 0
    this.realPlayingTime = 0
    this.callCount = 0
    this.needPreCheckCall = true
    this.fastMarkedList = {} 
    this.fastMarkedListWithCardId ={}
    IsAccelerateTime = false
    isPause = false
    this.gameType = ModelList.BattleModel:GetGameType()
    GetForbidCall()
    --CheckNextNumber()
    this:CheckSuperMatchRequire()
    this.update_x_enabled = true
    this:start_x_update()
    --CreateCallInfo()
end

function CallNumberMachine:CheckSuperMatchRequire()
    this.isSuperMatch = ModelList.BattleModel.GetBattleSuperMatch()
    if this.isSuperMatch then
        if not this.superMatchMachine then
            this.superMatchMachine = require("Combat/Machine/CallNumber/SuperMatchCallNumberMachine")
        end
        this.superMatchMachine:Init()
    end
end

function CallNumberMachine:Stop()
    this:stop_x_update()
    if this.superMatchMachine then
        this.superMatchMachine:Stop()
    end
end

function CallNumberMachine:Pause(Pause)
    self.update_x_enabled = not Pause
    isPause = Pause
end

--- 检查是否要加快叫号速度
local CheckAccelerateTime = function()
    if not IsAccelerateTime and this.realPlayingTime - this.playingTime > 1 then
        IsAccelerateTime = true
        Event.Brocast(EventName.Accelerate_Progress_With_Magnifier, true)
        Event.Brocast(EventName.Accelerate_Progress_With_Bingoleft_Tick, CallAcceleration)
    elseif IsAccelerateTime and this.realPlayingTime - this.playingTime <= 1 then
        IsAccelerateTime = false
        Event.Brocast(EventName.Accelerate_Progress_With_Magnifier, false)
        Event.Brocast(EventName.Accelerate_Progress_With_Bingoleft_Tick, 1)
    end
    if IsAccelerateTime then
        this.playingTime = this.playingTime + UnityEngine.Time.deltaTime * CallAcceleration
    else
        this.playingTime = this.playingTime + UnityEngine.Time.deltaTime
    end
end

function CallNumberMachine:on_x_update()
    if isPause  then return end
    this.realPlayingTime = this.realPlayingTime + UnityEngine.Time.deltaTime
    this.timing = this.timing + UnityEngine.Time.deltaTime
    --log.g("CallNumberMachine  realPlayingTime " .. this.playingTime)
    --log.g("CallNumberMachine  timing PlayingTime " .. this.timing)
    if not self.update_x_enabled then
        return
    end
    CheckAccelerateTime()
    if this.needPreCheckCall and this.playingTime - (this.interval * this.callCount) + 0.5 > 0 then
        --CheckNextNumber()
        this.needPreCheckCall = false
    end
    if this.playingTime - this.interval * this.callCount > 0 then
        --log.g("CreateCallInfo  " .. this.playingTime)
        CreateCallInfo()
        this.needPreCheckCall = true
    end
    if this.superMatchMachine then
        this.superMatchMachine:on_x_update(this.realPlayingTime)
    end

end

function CallNumberMachine.ChangeSpeed(owner, speedType)
    local type = ModelList.BattleModel:GetGameType()
    if type == PLAY_TYPE.PLAY_TYPE_AUTO_TICKET then
        if speedType == 0 or speedType == 2 then
            this.interval = Csv.GetData("control", 36, "content")[1][1]
        else
            this.interval = Csv.GetData("control", 45, "content")[1][1]
        end
    end
    Event.Brocast(EventName.Change_Call_Number_CD, this.interval)
end

function CallNumberMachine:GetDefaultCallCD()
    this.interval = this.callCd
    --local type = ModelList.BattleModel:GetGameType()
    --if type ~= PLAY_TYPE.PLAY_TYPE_AUTO_TICKET then
    --    this.interval = this.callCd
    --else
    --    --this.interval = Csv.GetData("control", 36, "content")[1][1]
    --    this.interval = Csv.GetControlByName("auto_callcd_2")[1][1]
    --    --local curr_speed = fun.read_value(MCT.HangUpSpeedConfig, 0)
    --    --if curr_speed == 0 or curr_speed == 2 then
    --    --else
    --    --    this.interval = Csv.GetData("control", 45, "content")[1][1]
    --    --end
    --end
    Event.Brocast(EventName.Change_Call_Number_CD, this.interval)
end

local AddFastByCardId = function(cardId )
    cardId = tonumber(cardId)
    if not this.fastMarkedListWithCardId[cardId] then
        this.fastMarkedListWithCardId[cardId] = 1
    else
        this.fastMarkedListWithCardId[cardId] = this.fastMarkedListWithCardId[cardId] + 1
    end
end

function CallNumberMachine:RecordFastClick(clickType, cardNum,cardid)
    if this.timing <= fastClickTime and lastNumber == cardNum then
        local temp = clickType * 100 + lastNumber
        if not fun.is_include(temp, this.fastMarkedList) then
            table.insert(this.fastMarkedList, temp)
            AddFastByCardId(cardid)
            --log.log(cardNum .. "     快速点击  ")
        end
    end
end

function CallNumberMachine:IsFastClick(num, doubleNum)
    if  (this.timing <= fastClickTime  or this.IsCallingNumber )and (lastNumber == num or lastNumber == doubleNum) then
        return true
    end
    return false
end

function CallNumberMachine.ResetFastMarkTime()
    this.timing = 0
    this.IsCallingNumber = false
end

function CallNumberMachine.GetFastClickData()
    return this.fastMarkedList
end

function CallNumberMachine.GetFastClickDataByCardId()
    return this.fastMarkedListWithCardId
end

function CallNumberMachine.Register()
    Event.AddListener(EventName.CallNumberMachine_Quick_Click, this.RecordFastClick)
    Event.AddListener(EventName.CallNumberMachine_Reset_Fast_Click, this.ResetFastMarkTime)
end

function CallNumberMachine.UnRegister()
    Event.RemoveListener(EventName.CallNumberMachine_Quick_Click, this.RecordFastClick)
    Event.RemoveListener(EventName.CallNumberMachine_Reset_Fast_Click, this.ResetFastMarkTime)
end

function CallNumberMachine:GetInterval()
    if not this.interval then
        this.interval = Csv.GetData("control", 1, "content")[1][1]
    end
    return this.interval
end

function CallNumberMachine:GetLeftCallNumberCount()
    if this.numList then
        return #this.numList
    end
    return 0
end



--- 获取被pu占有的单元格
function CallNumberMachine:GetCellHoldByPu(card_id)
    local posList = {}
    table.walk(this.powerUpData and this.powerUpData.powerUpList, function(v)
        if not v.isUsed then
            table.walk(v.cardEffect, function(v1)
                local cardId, effectData = v1.cardId, v1.effectData
                if cardId == card_id then
                    local list1 = BattleTool.GetFromServerPos(effectData.posList)
                    if GetTableLength(list1) > 0 then
                        posList = fun.add_table(posList, list1)
                    end
                    local list2 = BattleTool.GetFromServerPos(effectData.extraPos)
                    if GetTableLength(list2) > 0 then
                        posList = fun.add_table(posList, list2)
                    end
                    posList = fun.table_unique(posList)
                end
            end)
        end
    end)
    return posList
end

--- 收集战斗数据,供出错时分析
---上报 是否在后台/是否网络重连过/网络重连时间/最近的战斗
function CallNumberMachine:CollectBattleData()
    if not this.battleData then
        this.battleData = {}
    end
    this.battleData = fun.add_table(this.battleData, this.model:GetRoundData())


end

return this