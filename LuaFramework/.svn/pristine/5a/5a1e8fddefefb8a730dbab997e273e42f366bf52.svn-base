---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2023/2/7 15:19
---

require 'Model/ModelPart/BaseGameModel'
local bingoJokerMachine = require("Combat.Machine.BingoJokerMachine")

--- 普通玩法 Model
---@class SingleWolfGameModel : BaseGameModel
local SingleWolfGameModel = BaseGameModel:New()
local this = SingleWolfGameModel
this.rocketSettleData = nil
this.clawSkillDataCache = {}
this.moonSkillDataCache = {}
this.usedSignPos = {}
this.puUsedPos = {}
this.cardSignLogicDelayTime = 0
local private = {}

function SingleWolfGameModel:InitData()
    if not self:IsInit() then
        this:SetSelfGameType(PLAY_TYPE.PLAY_TYPE_WOLF)
        self:SetInit()
    end
end

function SingleWolfGameModel:GetQuestItemOffsetPos()
    return 30, -31
end

--请求进入游戏   ratio_str = “2,3” :卡片数量,倍率
function SingleWolfGameModel:ReqEnterGame(cb)
    this.reqEnterGameCb = cb
    if not this:CheckCityIsOpen() then
        fun.SafeCall(cb, false)
        return
    end
    
    ModelList.BattleModel:DirectSetGameType(PLAY_TYPE.PLAY_TYPE_WOLF,8)
    ModelList.CityModel.SetPlayId(8)
    this:SetReadyState(0)
    local procedure = require "Procedure/ProcedureSingleWolf"
    Facade.SendNotification(NotifyName.ShowUI, ViewList.SceneLoadingGameView,nil,nil,procedure:New())
    local cardNum = ModelList.CityModel:GetCardNumber()
    local betRate = ModelList.CityModel:GetBetRate()
    local powerupGear,powerupId = ModelList.CityModel:GetPowerupGear()
    local city = ModelList.CityModel:GetCity()
    local coupon = ModelList.CouponModel.get_currentCouponIdByCardNum(cardNum)
    local useId = ModelList.CouponModel.get_currentCouponUseIdByCardNum(cardNum)
    ModelList.CityModel:SavePreviousPlayInfo()
    this:ResetSettleCode()
    local hideCardAuto = ModelList.BattleModel.GetIsAutoSign() and 1 or 0
    this.SendMessage(MSG_ID.MSG_GAME_LOAD_WOLF, {cardNum = cardNum,rate = betRate,powerUpId = tonumber(powerupId),
                                                     cityId = city,couponId = coupon,useCouponId = useId,playId = ModelList.CityModel.GetPlayIdByCity(city),
                                                     hideCardAuto=hideCardAuto});

    --- 以下是测试代码
    --   ModelList.CityModel.C2S_ChangeCity(2)
    --   local city = ModelList.CityModel:GetCity()
    --   local limit = Csv.GetData("city",city,"openlevel")
    --   if ModelList.PlayerInfoModel:GetLevel() < limit then
    --       UIUtil.show_common_error_popup(8023,true,nil)
    --       return
    --   end
    --

    --    ModelList.CityModel.C2S_ChangeCity(2)
    --   ModelList.BattleModel:DirectSetGameType(PLAY_TYPE.PLAY_TYPE_WOLF_SINGLE,8)
    --   ModelList.CityModel.SetPlayId(8)
    --   this:SetReadyState(0)
    --    Facade.SendNotification(NotifyName.ShowUI, ViewList.SceneLoadingGameView,nil,nil,ProcedureSingleWolf:New())
    --   --Facade.SendNotification(NotifyName.ShowUI, ViewList.SceneLoadingGameView)
    --   local cardNum = ModelList.CityModel:GetCardNumber()
    --   local betRate = ModelList.CityModel:GetBetRate()
    --   local powerupGear,powerupId = ModelList.CityModel:GetPowerupGear()
    --   local city = ModelList.CityModel:GetCity()
    --   local coupon = ModelList.CouponModel.get_currentCouponIdByCardNum(cardNum)
    --   local useId = ModelList.CouponModel.get_currentCouponUseIdByCardNum(cardNum)
    --   ModelList.CityModel:SavePreviousPlayInfo()
    --   this:ResetSettleCode()
    --   local hideCardAuto = ModelList.BattleModel.GetIsAutoSign() and 1 or 0
    --   this.SendMessage(MSG_ID.MSG_GAME_LOAD_WOLF_SINGLE, {cardNum = 2,rate = betRate,powerUpId = tonumber(powerupId),
    --                                                    cityId = city,couponId = coupon,useCouponId = useId,playId = ModelList.CityModel.GetPlayIdByCity(city),hideCardAuto=hideCardAuto});
end

--请求卡片签章
function SingleWolfGameModel:ReqSignCard(info)
    local cardIds = {}
    for i = 1, #info.total do
        if this:RefreshRoundDataByIndex(info.total[i].cardId, info.total[i].index, 1, nil, info.total[i].mask) then
            if not fun.is_include(info.total[i].cardId,cardIds) then
                table.insert(cardIds,info.total[i].cardId)
            end
            this:CalcuateBingo(info.total[i].cardId,info.total[i].index,info.total[i].number)
        end
    end
    for i = 1, #cardIds do
        --this:CalcuateBingo(cardIds[i])
    end
end

--@param mark  --盖章方式 0=叫号 powerUpId=powerUp盖章的powerUpId  9=小火箭
function SingleWolfGameModel:RefreshRoundDataByIndex(cardid, cellIndex, signType, need_fly_item, mark,extraPos, ignoreWolfSign)
    local cardView = ModelList.BattleModel:GetCurrBattleView():GetCardView()

    if not ignoreWolfSign then
        local cellData = self.roundData:GetCell(cardid, cellIndex)
        --有狼族印记
        if cellData.haveWolfSign then
            cellData.haveWolfSign = false
            --狼族印记sign表现
            cardView:ShowWolfSignEffect(cardid, cellIndex)
        end
    end

    ---盖章成功，增加检查监狱层数
    local signSuccCall = function()
        local affectCellList = BattleLogic.GetLogicModule(LogicName.Card_logic):ReduceLogicPrison(cardid,cellIndex)
        if #affectCellList > 0 then
            self.cardSignLogicDelayTime = os.time()
        end
        cardView:AffectRoundCellPrison(cardid,affectCellList ,extraPos)
    end
    --父类处理
    return self.__index:RefreshRoundDataByIndex(cardid, cellIndex, signType, need_fly_item, mark,nil,signSuccCall)
end

--收到进入游戏返回，允许进入Game场景
function SingleWolfGameModel.ResEnterGame(code,data)
    private.OnResEnterGame(data)
    if(code == RET.RET_SUCCESS)then
        this:SaveGameLoadData(data)
        this:SetReadyState(1)
        this:InitRoundData()
        this:InitExtraData(data.ext)
        ModelList.BattleModel.SetBattleDouble(data.activityStatus)
        ModelList.BattleModel.SetIsJokerMachine( ( ( data.jokerData and #data.jokerData>0  ) or ModelList.CityModel:IsMaxBetRate()   ) and true or false)
        ModelList.BattleModel:BackupLoadData(data)
        this:SetGameState(GameState.Ready)
        Event.Brocast(EventName.Recorder_Data,5001,data)
        fun.SafeCall(this.reqEnterGameCb, true)
    else
        log.r("发送进入游戏失败"..code)
        Event.Brocast(EventName.Event_Cancel_Loading_Game)
        UIUtil.return_to_scenehome()
        UIUtil.show_common_global_popup(8004,true)
        fun.SafeCall(this.reqEnterGameCb, false)
    end
    this.reqEnterGameCb = nil
end


--后端Bingo同步
function SingleWolfGameModel:ResBingoInfo(code,data)
    if(code == RET.RET_SUCCESS)then
        this:SaveBingoLeftInfo(data)
        if this.onlySaveBingoInfo then return end
        this:RefreshBingoInfo()
        Facade.SendNotification(NotifyName.Bingo.Sync_Bingos)
        if data.bingoLeft <= 10 then
            UISound.set_bgm_volume(0.7)
        end
        if data.bingoLeft <= 0 and this:GetReadyState() == 1 then
            this:SetReadyState(2)
            LuaTimer:SetDelayFunction(MCT.delay_to_show_settle ,function()
                this.loop_delay_settle = LuaTimer:SetDelayLoopFunction(0.1,0.1,100,function()
                    --if this:IsGameSettling() then
                    this:ShowSettle()
                    LuaTimer:Remove(this.loop_delay_settle)
                    --end
                end,nil, nil,LuaTimer.TimerType.Battle)
            end)
        end
    else
        log.w("同步Bingo错误")
    end
end

function SingleWolfGameModel:OnReceiveSettle()
    if self:GetGameState() < GameState.ShowSettle then
        self:ShowSettle()
    end
end


function SingleWolfGameModel:Clear()
    table.each(self.loop_delay_checks, function(v)
        LuaTimer:Remove(v)
    end)
    
    this.rocketSettleData = nil
    this.__index:Clear()
end

--- 卡面上的bingo表现有延迟，确保最新一个bingo效果能满足最低存活时间
function SingleWolfGameModel:IsBingoShowComplete()
    local check = self.__index:IsBingoShowComplete()
    --cell被盖章后飞出道具及做动画的时间
    local checkTime = os.time() - self.cardSignLogicDelayTime > 3
    return check and checkTime
end

--刷新盖章计时，因为狼人的盖章动画结束后才会真正盖章
function SingleWolfGameModel:RefreshSignLogicDelayTime()
    self.cardSignLogicDelayTime = os.time()
end

--- 需要等特效还有bingo画面啥的都得等播放完再弹出结算界面
--- 战斗结算前，检查彩球叫号器
function SingleWolfGameModel:CheckJokerBallSprayer(callBack)
    local haveJokerBall = ModelList.BattleModel.HasJokerBallSprayer()
    private.StartSkillEmptyCheck(function()
        local cb = function()
            if haveJokerBall then
                --有彩球喷射器，等技能、盖章效果播完再继续彩球喷射器
                --这里等4秒是因为彩球喷射器动画太长，要等动画播完才走盖章逻辑
                LuaTimer:SetDelayFunction(4,function()
                    private.StartSkillEmptyCheck(function()
                        callBack()
                    end)
                end)
            else
                --没有彩球喷射器，等技能、盖章效果播完直接打开结算界面
                callBack()
            end
        end
        bingoJokerMachine:CheckJokerBallSprayer(cb)
    end)
end

function SingleWolfGameModel:SetRoundGiftData(card_id,cell_index,new_gift,number,skill_id, self_bingo,powerId,extraPos)
    self.__index.SetRoundGiftData(self, card_id,cell_index,new_gift,number,skill_id, self_bingo,powerId,extraPos)
    if powerId == 137 then
        --记录狼爪技能数据，结束上传
        table.insert(this.clawSkillDataCache, {
            cardId = tonumber(card_id),
            cellIndex = cell_index,
        })
    end
    if powerId == 130 then
        --记录圆月技能数据，结束上传
        table.insert(this.moonSkillDataCache, {
            cardId = tonumber(card_id),
            cellIndex = cell_index,
        })
    end
end

--请求游戏结束
function SingleWolfGameModel:ReqQuitBingoGame(pre_quit, gameType)
    --回放模式下，需要预计算数据
    if fun.IsEditor() then
        if BingoBangEntry.IsReplayBattle then
            if self.roundData ~= nil and self.roundData.GetRoundData ~= nil then
                self:PreCalculateClawSkill()
                self:PreCalculateMoonSkill()
                self:PreCalculateSignPos()
            end
        end
    end
    
    self.__index.ReqQuitBingoGame(self, pre_quit, gameType)
end

function SingleWolfGameModel:UploadGameData(gameType, quiteType)
    if self.roundData ~= nil and self.roundData.GetRoundData ~= nil then
        self:PreCalculateClawSkill()
        self:PreCalculateMoonSkill()
        self:PreCalculateSignPos()
    end
    self.__index.UploadGameData(self, gameType, quiteType)
end

-----------------狼爪技能----------------------------------------------

---提前计算好狼爪的数据，上传到服务器
function SingleWolfGameModel:PreCalculateClawSkill()
    table.each(this.clawSkillDataCache, function(v)
        local cellData = self:GetRoundData(v.cardId, v.cellIndex)
        if not cellData:IsNotSign() then
            return
        end

        local clawData = self:GetWolfClawSkillData(v.cardId, v.cellIndex)
        local wolfPosList = self:GetValidWolfForClawSkill(v.cardId, v.cellIndex)
        clawData.isPreCheck = 1
        
        --添加ExtraData，结算时通知服务器
        self:GetRoundData(v.cardId):AddExtraUpLoadData("wolfClaw", clawData, "pos")
    end)
end

---取可以用于狼爪技能的狼
function SingleWolfGameModel:GetValidWolfForClawSkill(cardId, cellIndex, excludeWolfPos)
    cardId = tonumber(cardId)

    local clawData = self:GetWolfClawSkillData(cardId, cellIndex)
    if ModelList.BattleModel:IsRocket() then
        return BattleTool.GetFromServerPos(clawData.wolfPos)
    end
    
    local logicModule, ret, needCount = BattleLogic.GetLogicModule(LogicName.Card_logic), {}, 0
    if logicModule:IsJackpot(cardId) then
        clawData.wolfPos = {24}
        return
    end

    if #clawData.wolfPos > 0 then
        table.each(clawData.wolfPos, function(v)
            local wolfPos = ConvertServerPos(v)
            local isBreak = logicModule:IsWolfBreadPrison(cardId, wolfPos)
            if not isBreak then
                table.insert(ret, wolfPos)
            else
                needCount = needCount + 1
            end
        end)
    else
        needCount = 1
    end

    --需要挑选新的狼
    if needCount > 0 then
        local posList = logicModule:GetLockedWolfForPreCal(cardId, needCount, excludeWolfPos)
        table.each(posList, function(v)
            table.insert(ret, v)
        end)
    end
    
    clawData.wolfPos = BattleTool.ConvertedToServerPosList(ret)    
    return ret
end

---获取狼爪技能的数据
function SingleWolfGameModel:GetWolfClawSkillData(cardId, cellIndex)
    cardId = tonumber(cardId)
    local data = self:GetBattleExtraInfo("wolfClawData")
    if not data then
        return
    end

    local clawData = table.find(data, function(k, v)
        local pos = ConvertServerPos(v.pos)
        return pos == cellIndex and v.cardId == cardId
    end)
    
    if not clawData then
        --后端未提供数据，前端自己算
        clawData = {
            cardId = cardId,
            pos = ConvertCellIndexToServerPos(cellIndex),
            wolfPos = {},
        }
        --更改本地数据
        table.insert(data, clawData)
    end
    
    return clawData
end

-----------------圆月技能----------------------------------------------

---提前计算好圆月的数据，上传到服务器
function SingleWolfGameModel:PreCalculateMoonSkill()
    table.each(this.moonSkillDataCache, function(v)
        local cellData = self:GetRoundData(v.cardId, v.cellIndex)
        if not cellData:IsNotSign() then
            return
        end

        local moonData = self:GetMoonSkillData(v.cardId, v.cellIndex)
        local wolfPos = self:GetValidWolfForMoonSkill(v.cardId, v.cellIndex)
        moonData.isPreCheck = 1

        --添加ExtraData，结算时通知服务器
        self:GetRoundData(v.cardId):AddExtraUpLoadData("wolfMoon", moonData, "pos")
    end)
end

---取可以用于圆月技能的狼
function SingleWolfGameModel:GetValidWolfForMoonSkill(cardId, cellIndex, excludeWolfPos)
    cardId = tonumber(cardId)
    
    local moonData = self:GetMoonSkillData(cardId, cellIndex)
    if ModelList.BattleModel:IsRocket() then
        return ConvertServerPos(moonData.wolfPos)
    end

    local logicModule, ret = BattleLogic.GetLogicModule(LogicName.Card_logic)
    if logicModule:IsJackpot(cardId) then
        moonData.wolfPos = 24
        return
    end
    
    if moonData.wolfPos and moonData.wolfPos > 0 then
        local pos = ConvertServerPos(moonData.wolfPos)
        local isBreak = logicModule:IsWolfBreadPrison(cardId, pos)
        if isBreak then
            ret = logicModule:GetLockedWolfForPreCal(cardId, 1, excludeWolfPos, true)
            ret = ret[1]
        else
            ret = pos
        end
    else
        ret = logicModule:GetLockedWolfForPreCal(cardId, 1, excludeWolfPos, true)
        ret = ret[1]
    end

    if not ret then
        moonData.wolfPos = 0
        return
    end
    
    moonData.wolfPos = ConvertCellIndexToServerPos(ret)
    return ret
end

function SingleWolfGameModel:GetMoonSkillData(cardId, cellIndex)
    cardId = tonumber(cardId)
    local wolfMoonData = self:GetBattleExtraInfo("wolfMoon")
    if not wolfMoonData then
        return
    end

    local moonData = table.find(wolfMoonData, function(k, v)
        local pos = ConvertServerPos(v.pos)
        return pos == cellIndex and v.cardId == cardId
    end)

    if not moonData then
        --后端未提供数据，前端自己算
        moonData = {
            cardId = cardId,
            pos = ConvertCellIndexToServerPos(cellIndex),
            wolfPos = 0,
        }
        --更改本地数据
        table.insert(wolfMoonData, moonData)
    end

    return moonData
end

-----------------狼人印记----------------------------------------------

---提前计算印记的数据，上传到服务器
function SingleWolfGameModel:PreCalculateSignPos()
    local cardView = ModelList.BattleModel:GetCurrBattleView():GetCardView()
    local cardCount = self:GetCardCount()
    local wolfPosList = {7, 9, 17, 19}
    
    for i = 1, cardCount do
        local signExtData = self:GetRoundData(i):GetExtraUpLoadData("wolfSign")
        table.each(wolfPosList, function(wolfPos)
            
            local find = table.find(signExtData, function(k, v)
                local pos = ConvertServerPos(v.wolfPos)
                return pos == wolfPos
            end)
            if not find then
                local data = self:GetSignData(i, wolfPos)
                if data.signPos ~= 0 then
                    local signPos = ConvertServerPos(data.signPos)
                    local cellData = self:GetRoundData(i, signPos)
                    if cellData then
                        if not cellData:IsNotSign() then
                            self:GetValidPosForSign(i, wolfPos)
                        end
                    else
                        self:GetValidPosForSign(i, wolfPos)
                    end
                else
                    self:GetValidPosForSign(i, wolfPos)
                end
                
                self:GetRoundData(i):AddExtraUpLoadData("wolfSign", data, "wolfPos")
            end
        end)
    end
end

---取可以用于放印记的格子
function SingleWolfGameModel:GetValidPosForSign(cardId, wolfPos)
    cardId = tonumber(cardId)
    
    local data = self:GetSignData(cardId, wolfPos)
    if ModelList.BattleModel:IsRocket() then
        return ConvertServerPos(data.signPos)
    end
    
    local logicModule, ret = BattleLogic.GetLogicModule(LogicName.Card_logic), {}
    if logicModule:IsJackpot(cardId) then
        data.signPos = 0
        return
    end
    
    if data.signPos and data.signPos > 0 then
        local pos = ConvertServerPos(data.signPos)
        local cellData = self:GetRoundData(cardId, pos)
        local isCellValid = private.CheckCellValidForWolfSign(cellData)
        if isCellValid then
            ret = pos
        else
            ret = private.FindPosForSign(cardId)
            if not ret then
                ret = private.FindPosForSign(cardId, true)
            end
        end
    else
        ret = private.FindPosForSign(cardId)
        if not ret then
            ret = private.FindPosForSign(cardId, true)
        end
    end

    if not ret then
        data.signPos = 0
        return
    end

    this.usedSignPos[cardId] = this.usedSignPos[cardId] or {}
    this.usedSignPos[cardId][ret] = true
    
    data.signPos = ConvertCellIndexToServerPos(ret)
    return ret
end

function SingleWolfGameModel:GetSignData(cardId, wolfPos)
    cardId = tonumber(cardId)
    local wolfSignData = self:GetBattleExtraInfo("wolfSign")
    if not wolfSignData then
        return
    end

    local signData = table.find(wolfSignData, function(k, v)
        local pos = ConvertServerPos(v.wolfPos)
        return pos == wolfPos and v.cardId == cardId
    end)

    if not signData then
        --后端未提供数据，前端自己算
        signData = {
            cardId = cardId,
            wolfPos = ConvertCellIndexToServerPos(wolfPos),
            signPos = 0,
        }
        --更改本地数据
        table.insert(wolfSignData, signData)
    end

    return signData
end

--格子是否可以放狼族印记
function SingleWolfGameModel:CheckValidPosForWolfSign(cardID, cellIndex)
    local cell = this:GetRoundData(cardID, cellIndex)
    local valid = private.CheckCellValidForWolfSign(cell)
    return valid
end

-----------------私有方法----------------------------------------------

---开始一场新的对局，初始化本地数据
function private.OnResEnterGame(loadData)
    this.clawSkillDataCache = {}
    this.moonSkillDataCache = {}
    this.loop_delay_checks = {}
    this.usedSignPos = {}

    private.InitPowerUpUseCells(loadData)
end

function private.InitPowerUpUseCells(loadData)
    this.puUsedPos = {}
    
    local powerUpData = loadData and loadData.powerUpData
    if powerUpData then
        table.each(powerUpData, function(puData)
            if puData.type == 1 then
                table.each(puData.cardEffect, function(ue)
                    this.puUsedPos[ue.cardId] = this.puUsedPos[ue.cardId] or {}
                    local temp = this.puUsedPos[ue.cardId]
                    local posList = BattleTool.GetFromServerPos(ue.posList)
                    fun.add_table(temp, posList)
                    this.puUsedPos[ue.cardId] = fun.table_unique(temp)
                end)
            end
        end)
    end
end

function private.FindPosForSign(cardId, ignoreGiftAndPu)
    this.usedSignPos[cardId] = this.usedSignPos[cardId] or {}
    local temp, ret, blowRollRet = this.usedSignPos[cardId]
    local allCell = this:GetRoundData(cardId).cards
    local nextPuPos = BattleTool.GetNextPowerUpPos(cardId)
    
    --倒序执行搜索，防止跟pu搜寻到同一个位置
    for i = #allCell, 1, -1 do
        local cell = allCell[i]
        local valid, canForceUse, isBlowRoll = private.CheckCellValidForWolfSign(cell, nextPuPos, ignoreGiftAndPu)
        local cellID = cell.index
        if valid then
            if not temp[cellID] then
                temp[cellID] = true
                return cellID
            end
        else
            if isBlowRoll and not blowRollRet then
                --当找不到可以使用的格子时，可以与吹吹卷重叠
                blowRollRet = cellID
            end
            if canForceUse and not ret then
                --当找不到可以与吹吹卷重叠的格子时
                ret = cellID
            end
        end
    end
    
    return blowRollRet or ret
end 

--格子是否可以放狼族印记
function private.CheckCellValidForWolfSign(cell, nextPuPos, ignoreGiftAndPu)
    nextPuPos = nextPuPos or BattleTool.GetNextPowerUpPos(cell.cardId)
    if nextPuPos and fun.is_include(cell.index, nextPuPos) then
        return false
    end
    
    --被其他印记占用
    if cell.haveWolfSign then
        return false
    end
    
    if not cell:IsNotSign() then
        return false
    end
    
    if not ignoreGiftAndPu then
        local puID = cell:GetPowerupId(1)
        if puID then
            return false
        end
        
        --后面会被pu使用的格子
        local puHitPos = this.puUsedPos[cell.cardId]
        local checkPuHitPos = puHitPos and fun.is_include(cell.index, puHitPos)
        if checkPuHitPos then
            return false
        end
        
        local giftCount, isFlash = cell:GetGiftCount(), cell:IsFlash()
        local checkGift = giftCount == 0 or (giftCount == 1 and isFlash)
        local jokerData = cell:GetJokerChange()
        local jokerCount = fun.table_len(cell:GetJokerChange())
        local haveJoker, isJokerArea = jokerCount > 0, cell:IsJokerArea()
        local checkJoker = not haveJoker or isJokerArea
        if checkGift and checkJoker then
            return true
        end

        if jokerCount == 1 then
            jokerData = jokerData[1]
            local isBlowRoll = jokerData.state == 3
            if isBlowRoll then
                return false, true, true
            end
        end

        if giftCount == 1 then
            return false, true
        end
        
        return false
    end
    
    return true
end

function private.StartSkillEmptyCheck(cb)
    local loop_delay_check
    loop_delay_check = LuaTimer:SetDelayLoopFunction(0.2,0.1,-1,function()
        local effectObjContainer = ModelList.BattleModel:GetCurrBattleView().effectObjContainer
        if effectObjContainer then
            local isSkillEmpty = effectObjContainer:IsSkillContainerEmpty()
            if isSkillEmpty then
                LuaTimer:Remove(loop_delay_check)
                cb()
            end
        else
            LuaTimer:Remove(loop_delay_check)
            cb()
        end
    end,nil, nil,LuaTimer.TimerType.Battle)
    table.insert(this.loop_delay_checks, loop_delay_check)
end

this.MsgIdList =
{
    { msgid = MSG_ID.MSG_GAME_LOAD_WOLF, func = this.ResEnterGame },
}

return this