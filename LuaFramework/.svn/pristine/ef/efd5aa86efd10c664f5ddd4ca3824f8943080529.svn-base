---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 18/11/2024 下午 2:49
---

--- 赛马bingo规则
local BaseBingoRule = require("Combat.Machine.CalculateBingo.BaseBingoRule")
local ChristmasSynthesisRule = BaseBingoRule:New("ChristmasSynthesisRule")
local this = ChristmasSynthesisRule

local CardInfo = {}
local currWishList = {}
local MaxWaterCount = {}
local wishItems = {}

local gridSize = 5

function ChristmasSynthesisRule:Start(loadData, wish_item)
    CardInfo = {}
    wishItems = {}
    currWishList = {}
    if wish_item then
        for i = 1, #wish_item do
            if wish_item[i] ~= 0 then
                table.insert(wishItems, wish_item[i])
            end
        end
    end
    local cardCount = #loadData.cardsInfo
    for i = 1, cardCount do
        CardInfo[i] = {
            map = this:GenerateMapSign(i);
            bingo = nil,       --能形成bingo的酒杯ID
            jackpot = 0,       --  0没有jackpot  1 形成了jackpot
            currBingoList = {} --当前卡面的bingo信息
        }
        currWishList[i] = {}
    end
    this:InitData()
    this.model = ModelList.BattleModel:GetCurrModel()
end

function ChristmasSynthesisRule:CalculateBingo(cardId, cellIndex, ...)
    local totalBingoInfoList = {}
    local newBingoInfoList = {}
    local num = { ... }

    cardId = tonumber(cardId)
    if CardInfo[cardId].bingo then
        --for i = 1, #CardInfo[cardId].bingo do
        local bingoInfo = this:CreateBingoInfo(this.BingoType.BINGO, num, cardId, CardInfo[cardId].bingo)
        bingoInfo.bingoType = this:GetBingoType(cardId, cellIndex)
        table.insert(newBingoInfoList, bingoInfo)
        CardInfo[cardId].bingo = nil
        --end
    end

    if #newBingoInfoList > 0 then
        fun.merge_array(totalBingoInfoList, newBingoInfoList)
    end

    if this:CalculateJackpot(cardId) then
        local bingoInfo = {
            type = this.BingoType.JACKPOT,
            numbers = num,
            cardId = cardId,
            totolCount = this.totalBingoCount[cardId],
            th = 0,
        }
        table.insert(totalBingoInfoList, bingoInfo)
        CardInfo[cardId].jackpot = 1
    end
    --this:CalculateCardWish(cardId)
    if #totalBingoInfoList > 0 then
        Event.Brocast(EventName.Player_Bingo_Reduce_Bingoleft, totalBingoInfoList, cardId)
    end
end

--- override 合成玩法添加额外信息
function ChristmasSynthesisRule:CreateBingoInfo(bingoType, numbers, cardId, bingo)
    self:AddTotalBingoCount(cardId)
    local bingoInfo = {
        type = bingoType,
        numbers = { bingo.firstCellIndex },
        cardId = cardId,
        totolCount = self.totalBingoCount[cardId],
        th = 0 --BingoOrderMachine:GetRecordBingoOrder(cardId)
    }
    return bingoInfo
end

function ChristmasSynthesisRule:GetBingoType(cardId, cellIndex)
    local curModel = ModelList.BattleModel:GetCurrModel()
    local curCell = curModel:GetRoundData(cardId, cellIndex)

    --local treasureItems = curCell:Treasure2Item()
    --if treasureItems then
    --    local data = Csv.GetData("item", treasureItems.id)
    --    if 52 == data.result[1] then
    --        return data.result[2] or 1
    --    end
    --end

    return 2
end

function ChristmasSynthesisRule:OnDataChange(cardId, cellIndex, ...)
    --local arg                       = { ... }
    --local bowlType                  = arg[1]
    --local addCount                  = arg[2]
    cardId                          = tonumber(cardId)
    CardInfo[cardId].map[cellIndex] = 1
    local BingoGrid                 = this:MainCheckSignMap(cardId)
    local maxWeight                 = nil
    if BingoGrid and #BingoGrid > 0 then
        CardInfo[cardId].bingo = BingoGrid[1]
        maxWeight = BingoGrid[1].weight
        this:OnNewBingo(cardId, BingoGrid[1])
        this:CalculateBingo(cardId, cellIndex)
    end

    this:CalculateCardWish(cardId, maxWeight)
end

--- 临时保存新形成的格子bingo信息
function ChristmasSynthesisRule:OnNewBingo(cardId, data)
    if not this.TempBingoInfo then this.TempBingoInfo = {} end
    this.TempBingoInfo[cardId] = data
end

function ChristmasSynthesisRule:CalculateJackpot(cardId)
    if CardInfo[cardId].jackpot == 1 then
        return false
    end
    return this:IsMapAllSign(cardId)
end

function ChristmasSynthesisRule:ForceBingo()
    local max = 0
    local type = 0
    for i = 1, #CardInfo do
        if CardInfo[i] > max and CardInfo[i] < MaxWaterCount[i] then
            max = CardInfo[i]
            type = i
        end
    end
    return max, CardInfo
end

--- 计算是否出现wish,
function ChristmasSynthesisRule:CalculateCardWish(cardId, maxWeight)
    --local needShowThreeWish = false
    local data = this:CheckAllWishPatterns(cardId, maxWeight)
    local lastWishList = currWishList[cardId]
    if data and #data > 0 then
        currWishList[cardId] = {}
        --needShowThreeWish = true
        for i = 1, #data do
            Event.Brocast(EventName.CardBingoEffect_ShowWish, cardId, data[i].wishCellIndex)
            table.insert(currWishList[cardId], data[i].wishCellIndex)
        end
        table.each(currWishList[cardId], function (v, k)
            fun.remove_table_item(lastWishList, v)
        end)
    end
    --if not needShowThreeWish then
    --if #lastWishList > 0 then
        if lastWishList and #lastWishList > 0 then
            for i = 1, #lastWishList do
                Event.Brocast(EventName.CardBingoEffect_CancelShowWish, cardId, lastWishList[i])
            end
        end
        --currWishList[cardId] = {}
    --end

end

--- 生成每个卡牌的盖章地图
function ChristmasSynthesisRule:GenerateMapSign()
    local grdiSignMap = {}
    for i = 1, 25 do
        grdiSignMap[i] = 0
    end
    return grdiSignMap
end

--- 检查grdiSignMap是否有未盖章的格子
function ChristmasSynthesisRule:IsMapAllSign(cardId)
    for i = 1, #CardInfo[cardId].map do
        if CardInfo[cardId].map[i] == 0 then
            return false
        end
    end
    return true
end

-- 主程序
function ChristmasSynthesisRule:MainCheckSignMap(cardId)
    --- 开发代码
    --print("涂色后的棋盘：")
    --for y = 0, gridSize - 1 do
    --    for x = 0, gridSize - 1 do
    --        print(string.format("%s\t", this.grdiSignMap[(x * gridSize) + (y + 1)]))
    --    end
    --end

    -- 检查所有可能的图案
    local bingoGrid = this:CheckAllPatterns(cardId)
    return bingoGrid
end

-- 检查可能的图案
function ChristmasSynthesisRule:CheckAllPatterns(cardId)
    local patterns = {
        { 5, 5 },
        { 5, 4 },
        { 4, 5 },
        { 4, 4 },
        { 5, 3 },
        { 3, 5 },
        { 4, 3 },
        { 3, 4 },
        { 3, 3 },
    }
    local BingoGrid = {}
    for _, pattern in pairs(patterns) do
        local width, height = pattern[1], pattern[2]
        for y = 0, height - 1 do
            for x = 0, width - 1 do
                if this:CheckPattern(CardInfo[cardId].map, x, y, width, height) then
                    if not this:CheckOverlap(cardId, (y * gridSize) + (x + 1), width, height) then
                        log.g(width .. "   " .. height .. " " .. (y * gridSize + x + 1))
                        ---@class ChristmasSynthesisData
                        local data = {
                            cardId = cardId,
                            firstCellIndex = (y * gridSize) + (x + 1), --左上角格子的序号
                            width = width,
                            height = height,
                            weight = width * height, -- 权重，可以自定义
                        }
                        table.insert(BingoGrid, data)
                        --this:SaveBingoGrid(cardId, data)
                    end
                end
            end
        end
    end
    table.sort(BingoGrid, function (a, b)
        if a.weight == b.weight then
            local ax = a.firstCellIndex % gridSize
            local ay = math.floor(a.firstCellIndex / gridSize)
            local bx = b.firstCellIndex % gridSize
            local by = math.floor(b.firstCellIndex / gridSize)
            local cx = 0
            local cy = 0
            if CardInfo[cardId].currBingoList then
                if CardInfo[cardId].currBingoList.firstCellIndex then
                    cx = CardInfo[cardId].currBingoList.firstCellIndex % gridSize
                    cy = math.floor(CardInfo[cardId].currBingoList.firstCellIndex / gridSize)
                end
            end
            return math.abs(ax - cx) + math.abs(ay - cy) < math.abs(bx - cx) + math.abs(by - cy)
        else
            return a.weight > b.weight
        end
    end)
    return BingoGrid
end

-- 检查给定的格子周围的区域是否能组成指定大小的形状
function ChristmasSynthesisRule:CheckPattern(grdiSignMap, startX, startY, width, height)
    local firstColor = grdiSignMap[(startY * gridSize) + (startX + 1)] -- 获取左上角格子的盖章
    if firstColor == 0 then return false end
    for j = 0, height - 1 do
        for i = 0, width - 1 do
            local x = startX + i
            local y = startY + j
            if x < 0 or y < 0 or x >= gridSize or y >= gridSize then
                return false -- 超出边界
            end
            if grdiSignMap[(y * gridSize) + (x + 1)] ~= firstColor then
                return false -- 盖章不一致
            end
        end
    end
    return true -- 找到一致的盖章区域
end

--- 是否和现有BingoGrid重合了
function ChristmasSynthesisRule:CheckOverlap(cardId, firstCellIndex, width, height)
    if CardInfo[cardId].currBingoList and CardInfo[cardId].currBingoList.firstCellIndex then
        local data = CardInfo[cardId].currBingoList
        if data.weight >= width * height then
            return true
        end
        if data.firstCellIndex == firstCellIndex and data.width == width and data.height == height then
            return true
        end
    end
    return false
end

--- 保存当前使用中的BingoGrid
function ChristmasSynthesisRule:SaveBingoGrid(cardId, data)
    CardInfo[cardId].currBingoList = data
end

---有多个图案可选,选择一个最佳盖章图案
function ChristmasSynthesisRule:ChooseBestPattern(cardId, newGridList, oriBingoGrid)

end

--- 检查是否形成新的格子bingo
function ChristmasSynthesisRule:IsNewBingoMap(cardId)
    return (this.TempBingoInfo and this.TempBingoInfo[cardId]) and true or false
end

--- 检查是否形成新的格子bingo
function ChristmasSynthesisRule:ClearNewBingoMap(cardId)
    if this.TempBingoInfo and this.TempBingoInfo[cardId] then
        this.TempBingoInfo[cardId] = nil
    end
end

---提供一个查询接口,再内部自定义逻辑
function ChristmasSynthesisRule:SeekInfo(seekType, cardId)
    if seekType then
        if seekType == 1 then     -- 查询是否形成新的bingo
            return this:IsNewBingoMap(cardId)
        elseif seekType == 2 then -- 查询新成型的BingoGrid
            return this.TempBingoInfo[cardId]
        elseif seekType == 3 then --查询当前卡牌的bing数据
            return CardInfo[cardId] and CardInfo[cardId].currBingoList or nil
        elseif seekType == 4 then --查询卡牌的wish数据
            return this:CheckAllWishPatterns(cardId)
        end
    end

    return nil
end

--- 提供一个设置接口，再内部自定义逻辑
function ChristmasSynthesisRule:SetInfo(setType, ...)
    if setType == 1 then -- 保存新的BingoGrid
        local data = ({ ... })
        this:SaveBingoGrid(data[1], data[2])
        this:ClearNewBingoMap(data[1])
    end
end

-----------------------------------查找wish格子---------------------------------
-- 检查可能的图案
function ChristmasSynthesisRule:CheckAllWishPatterns(cardId, maxWeight)
    local patterns = {
        { 5, 5 },
        { 5, 4 },
        { 4, 5 },
        { 4, 4 },
        { 5, 3 },
        { 3, 5 },
        { 4, 3 },
        { 3, 4 },
        { 3, 3 },
    }
    local BingoGrid = {}
    for _, pattern in pairs(patterns) do
        local width, height = pattern[1], pattern[2]
        for y = 0, height - 1 do
            for x = 0, width - 1 do
                local isWish, wishCellIndex = this:CheckWishPattern(CardInfo[cardId].map, x, y, width, height)
                if isWish then
                    if not this:CheckWishOverlap(cardId, (y * gridSize) + (x + 1), width, height, maxWeight) then
                        --log.g(width .. "   " .. height .. " " .. (y * gridSize + x + 1))
                        ---@class : ChristmasSynthesisData2
                        local data = {
                            cardId = cardId,
                            wishCellIndex = wishCellIndex,             -- wish格子
                            firstCellIndex = (y * gridSize) + (x + 1), --左上角格子的序号
                            width = width,                             --从上到下的格子数
                            height = height,                           --从左到右的格子数
                            weight = width * height,                   -- 权重，可以自定义
                            cellIdxList = {}
                        }
                        for i = 0, width - 1 do
                            for j = 0, height - 1 do
                                table.insert(data.cellIdxList, data.firstCellIndex + j * 5 + i)
                            end
                        end
                        table.sort(data.cellIdxList)
                        table.insert(BingoGrid, data)
                    end
                end
            end
        end
    end
    table.sort(BingoGrid, function (a, b)
        if a.weight == b.weight then
            local ax = a.firstCellIndex % gridSize
            local ay = math.floor(a.firstCellIndex / gridSize)
            local bx = b.firstCellIndex % gridSize
            local by = math.floor(b.firstCellIndex / gridSize)
            local cx = 0
            local cy = 0
            if CardInfo[cardId].currBingoList then
                if CardInfo[cardId].currBingoList.firstCellIndex then
                    cx = CardInfo[cardId].currBingoList.firstCellIndex % gridSize
                    cy = math.floor(CardInfo[cardId].currBingoList.firstCellIndex / gridSize)
                end
            end
            return math.abs(ax - cx) + math.abs(ay - cy) < math.abs(bx - cx) + math.abs(by - cy)
        else
            return a.weight < b.weight
        end
    end)

    -- 用于存储已见的 firstCellIndex
    local seenIndices = {}
    -- 遍历表，移除宽度和高度乘积较小的子表
    for i = #BingoGrid, 1, -1 do
        local currentIndex = BingoGrid[i].wishCellIndex
        local currentArea = BingoGrid[i].width * BingoGrid[i].height

        if seenIndices[currentIndex] then
            -- 如果已见到相同的 firstCellIndex，比较面积
            local maxArea = seenIndices[currentIndex].area
            if currentArea <= maxArea then
                -- 如果当前面积更小，移除当前子表
                table.remove(BingoGrid, i)
            else
                -- 如果当前面积更大，更新存储的最大面积和对应的子表
                seenIndices[currentIndex] = {
                    area = currentArea,
                    index = i -- 保存当前子表的索引，如果需要可以参考
                }
            end
        else
            -- 否则，记录该 firstCellIndex 和面积
            seenIndices[currentIndex] = {
                area = currentArea,
                index = i
            }
        end
    end
    return BingoGrid
end

-- 检查给定的格子周围的区域是否能组成指定大小的形状
function ChristmasSynthesisRule:CheckWishPattern(grdiSignMap, startX, startY, width, height)
    local otherColorCount = 0
    local otherCellIndex = {}
    for j = 0, height - 1 do
        for i = 0, width - 1 do
            local x = startX + i
            local y = startY + j
            if x < 0 or y < 0 or x >= gridSize or y >= gridSize then
                return false -- 超出边界
            end
            if grdiSignMap[(y * gridSize) + (x + 1)] == 0 then
                otherColorCount = otherColorCount + 1
                table.insert(otherCellIndex, (y * gridSize) + (x + 1))
                if otherColorCount > 1 then
                    return false -- 多于一个非1颜色
                end
            end
        end
    end
    if otherColorCount == 1 then
        return true, otherCellIndex[1]
    end
    return false -- 找到一致的盖章区域
end

---
function ChristmasSynthesisRule:CheckWishOverlap(cardId, firstCellIndex, width, height, maxWeight)
    ---检查currBingoList的权重和当前卡面最大的权重是否一致
    if maxWeight then
        if width * height <= maxWeight then
            return true
        end
    end
    if not CardInfo[cardId].currBingoList or not CardInfo[cardId].currBingoList.weight then return false end
    if CardInfo[cardId].currBingoList and CardInfo[cardId].currBingoList.firstCellIndex then
        local data = CardInfo[cardId].currBingoList
        if data.weight >= width * height then
            return true
        end
        if data.firstCellIndex == firstCellIndex and data.width == width and data.height == height then
            return true
        end
    end
    return false
end

--- 获取cardId卡面最大的权重数值
function ChristmasSynthesisRule:GetMaxWeight(cardId)

end

function ChristmasSynthesisRule:CheckWishGrid(cardId, grdiSignMap, bingoGrid, bingoGridIndex)

end

-----------------------------------结束查找wish格子---------------------------------



return this
