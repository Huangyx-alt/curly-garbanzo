---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2022/10/11 20:35
---

--- 多组形状盖章 规则 判断

local BaseBingoRule =  require("Combat.Machine.CalculateBingo.BaseBingoRule")

GoldenTrainBingoRule = BaseBingoRule:New("GoldenTrainBingoRule")
local this = GoldenTrainBingoRule
setmetatable(GoldenTrainBingoRule, {__index = BaseBingoRule})

this.isInit = false
this.bingoRule = nil
this.bingoCell = nil
this.BingoType = {BINGO = 1,JACKPOT = 2}

-- 获取每个格子key能形成bingo的所有排列规则
local InitBingoKeyArray = function()
    this.cellBingoKeyArray = {}
    this.cellBingoRulePathIdList = {}
    for i = 1, 25 do
        local temp = {}
        local tempIdList = {}
        --for m = 1, #this.bingoRule do
        for m = #this.bingoRule, 1, -1 do
            local temp2 = {}
            if fun.is_include(i, this.bingoRule[m]) then
                for n = 1, #this.bingoRule[m] do
                    table.insert(temp2, this.bingoRule[m][n])
                end
            end
            if #temp2 > 0 then
                table.insert(temp, temp2)
                table.insert(tempIdList, m)
            end
        end
        if #temp > 0 then
            this.cellBingoKeyArray[i] = temp
            this.cellBingoRulePathIdList[i] = tempIdList
        end
    end
end

function GoldenTrainBingoRule:Start(loadData)
    local  bingoRuleId = 1
    local jackpotRuleId = loadData.jackpotRuleId
    this.bingoRule = Csv.GetData("client_bingo_rule", bingoRuleId, "content")
    if #jackpotRuleId > 0 then
        this.jackpotRule = Csv.GetData("jackpot", jackpotRuleId[1], "coordinate")
    else
        this.jackpotRule = nil
    end
    InitBingoKeyArray()
    this.bingoCell = {}
    this:InitData()
    this.isInit = true
    this.data = ModelList.BattleModel:GetCurrModel():GetRoundData()
    local count = ModelList.BattleModel:GetCurrModel():GetCardCount()
    for i = 1, count do
        GoldenTrainBingoRule.OnInitCalcuateWish(i)
    end
    this.soundFlag = {}
end

-- 叫号时候 提前检查卡牌内可形成bingo列表的格子ID
local PreGetBingoCellIndexList = function(cellIndex, cardInfo, cardId)
    cardId = tonumber(cardId)
    for i = 1, #this.bingoCell do
        if this.bingoCell[i].cardId == cardId and this.bingoCell[i].index == cellIndex  then
            if cardInfo.cards[cellIndex].sign == 0 then
                return true
            end
        end
    end
    return false
end

---差一个就形成了Bingo
local function OnelessAchievedBingoEffect(cardId,cellIndex)
    Event.Brocast(EventName.CardBingoEffect_ShowWish,cardId,cellIndex)
end

--- 差一个格子就能形成Bingo
local oneLessAchievedBingoList = {}

--- 差一个格子就能形成Jackpot
local oneLessAchievedJackpotList = {}

--获取卡牌内可形成bingo列表的格子ID
local GetBingoIndexList = function(cellIndex, cardInfo, cardId)
    --检查bingo格 玩不允许用此pu,
    local newBingoInfoList = {}--GetBingoCellIndexList( cellIndex, cardInfo,cardId)
    --检查普通bingo
    local curModel = ModelList.BattleModel:GetCurrModel()
    for i = 1, #this.cellBingoKeyArray[cellIndex] do
        local keyArrayTemp = this.cellBingoKeyArray[cellIndex][i]
        local otherHasSign = true
        local lessAchievedBingoCount  = 0
        oneLessAchievedBingoList = {}
        for n = 1, #keyArrayTemp do
            local cell_index = keyArrayTemp[n]
            if cardInfo.cards[cell_index].sign == 0 and cell_index ~= cellIndex  then
                otherHasSign = false
                lessAchievedBingoCount = lessAchievedBingoCount + 1
                table.insert(oneLessAchievedBingoList, cell_index)
            elseif cardInfo.cards[cell_index].forbiddenSignType then
                otherHasSign = false
            end
        end
        if otherHasSign then
            local bingoInfo = this:CreateBingoInfo(this.BingoType.BINGO, keyArrayTemp, cardId, this.cellBingoRulePathIdList[cellIndex][i], cellIndex)
            table.insert(newBingoInfoList, bingoInfo)
            if curModel then
                curModel:RecordBingoInfo(cardId, bingoInfo)
            end
        else
            if curModel and curModel:CanShowNormalCellBingoWish() then
                ---差n个就形成了Bingo
                local needCount = curModel:GetLessAchievedBingoNeedCount()
                if lessAchievedBingoCount <= needCount and cardInfo.cards[cellIndex].sign > 0 then
                    table.each(oneLessAchievedBingoList, function(v)
                        if cardInfo.cards[v].wishState == 0 then
                            OnelessAchievedBingoEffect(cardId, v)
                            cardInfo.cards[v].wishState = 1
                        end
                    end)
                end
            end
        end
    end
    return newBingoInfoList
end

--- 计算技能盖章影响的其他格子，能否形成bingo
local CalBingoWithIgnoreList = function(cellIndex, cardInfo, ignoreList,cardId)
    ---影响的位置，有单Bingo道具，直接获取bingo
    if PreGetBingoCellIndexList(cellIndex,cardInfo,cardInfo.index)  then return true end
    for i = 1, #this.cellBingoKeyArray[cellIndex] do
        local keyArrayTemp = this.cellBingoKeyArray[cellIndex][i]
        local otherHasSign = true
        for n = 1, #keyArrayTemp do
            local cell_index = keyArrayTemp[n]
            if cardInfo.cards[cell_index].sign == 0 and cell_index ~= cellIndex and not fun.is_include(cell_index, ignoreList) then
                otherHasSign = false
                break
            end
        end
        if otherHasSign then
            return true
        end
    end
    return false
end

---获取不再形成bingo的 技能格子
local function GetCancelWishCell(wishedIndexList,cardInfo,cardId)
    local returnList = {}
    for i = 1, #wishedIndexList do
        local ignoreList = {}
        local canBingo = false
        for m = 1, #cardInfo.cards[wishedIndexList[i]].skill_id do
            this:GetIgnorePos(cardInfo.cards[wishedIndexList[i]].skill_id[m], wishedIndexList[i], ignoreList, cardInfo,cardId)
        end
        if #ignoreList >0 then
            local otherSkillBingo = CalBingoWithIgnoreList(wishedIndexList[i],cardInfo,ignoreList)
            if otherSkillBingo then
                canBingo = true
            else
                for n = 1, #ignoreList do
                    local canBingo = CalBingoWithIgnoreList(ignoreList[n],cardInfo,ignoreList)
                    if canBingo then
                        canBingo = true
                        break
                    end
                end
            end
        end
        if not canBingo then
            table.insert(returnList,wishedIndexList[i])
        end
    end
    return returnList
end


--获取卡牌内可形成bingo列表的技能格子
local GetCardMakeBingoSkillCellList = function(cardInfo,cardId)
    cardId = tonumber(cardId)
    local skillIndexList = {}
    local wishedSkillIndexList = {}
    for i = 1, #cardInfo.cards do
        if #cardInfo.cards[i].skill_id >0 and cardInfo.cards[i].sign == 0  then
            if cardInfo.cards[i].wishState == 0 then
                table.insert(skillIndexList,i)
            else
                table.insert(wishedSkillIndexList,i)
            end
        end
    end
    local returnList = {}
    for i = 1, #skillIndexList do
        local ignoreList = {}
        for m = 1, #cardInfo.cards[skillIndexList[i]].skill_id do
            this:GetIgnorePos(cardInfo.cards[skillIndexList[i]].skill_id[m], skillIndexList[i], ignoreList, cardInfo,cardId)
        end
        if #ignoreList >0 then
            local otherSkillBingo = CalBingoWithIgnoreList(skillIndexList[i],cardInfo,ignoreList)
            if otherSkillBingo then
                table.insert(returnList,skillIndexList[i])
            else
                for n = 1, #ignoreList do
                    local canBingo = CalBingoWithIgnoreList(ignoreList[n],cardInfo,ignoreList)
                    if canBingo then
                        table.insert(returnList,skillIndexList[i])
                        break
                    end
                end
            end
        end
    end
    return returnList , GetCancelWishCell(wishedSkillIndexList,cardInfo,cardId)
end

--- 假如卡牌内技能盖章后，是否能形成bingo，播放wish效果
local function CheckCalculateSkillMakeBingo (cellIndex, cardInfo,cardId)
    cardId = tonumber(cardId)
    local skillIndexList = {}
    if #cardInfo.cards[cellIndex].skill_id > 0 then
        skillIndexList = cardInfo.cards[cellIndex].skill_id
    end
    for i = 1, #skillIndexList do
        local ignoreList = {cellIndex}
        this:GetIgnorePos(skillIndexList[i], cellIndex, ignoreList, cardInfo,cardId)
        if #ignoreList >0 then
            local canBingo = false
            for m = 2, #ignoreList do
                local otherSkillBingo = CalBingoWithIgnoreList(ignoreList[m],cardInfo,ignoreList)
                if otherSkillBingo then
                    canBingo = true
                    break
                end
            end
            if canBingo then
                Event.Brocast(EventName.CardBingoEffect_ShowWish,cardId,cellIndex)
            end
        end
    end
end

--- 假如卡牌内技能盖章后，不能形成bingo，取消wish效果
local function CalculateCancelSkillMakeBingo (cellIndex, cardInfo,cardId)
    cardId = tonumber(cardId)
    ---5缺一的情况 不取消
    if CalBingoWithIgnoreList(cellIndex,cardInfo,{},cardId) then return end

    local skillIndexList = {}
    if #cardInfo.cards[cellIndex].skill_id > 0 then
        skillIndexList = cardInfo.cards[cellIndex].skill_id
    end
    local canBingo = false
    for i = 1, #skillIndexList do
        local ignoreList = {cellIndex}
        this:GetIgnorePos(skillIndexList[i], cellIndex, ignoreList, cardInfo,cardId)
        if #ignoreList >0 then
            for m = 2, #ignoreList do
                local otherSkillBingo = CalBingoWithIgnoreList(ignoreList[m],cardInfo,ignoreList)
                if otherSkillBingo then
                    canBingo = true
                    break
                end
            end
        end
    end
    if not canBingo then
        Event.Brocast(EventName.CardBingoEffect_CancelShowWish,cardId,cellIndex)
    end
end

function GoldenTrainBingoRule:CreateBingoInfo(bingoType, numbers, cardId, bingoPathId, lastCellIndex)
    self:AddTotalBingoCount(cardId)
    local bingoInfo = 
    { 
        type = bingoType, 
        numbers = deep_copy(numbers),
        cardId = cardId,
        totolCount = self.totalBingoCount[cardId],
        th = BingoOrderMachine:GetRecordBingoOrder(cardId),
        pathId = bingoPathId,
        lastCellIndex = lastCellIndex,
    }
    return bingoInfo
end

--- 计算是否出现bingo  盖章使用
---@param index
function GoldenTrainBingoRule:CalculateBingo(cardId, cellIndex)
    local totalBingoInfoList = {}
    for k, v in pairs(this.data) do
        local caidid = tostring(cardId)
        if k == caidid then
            local newBingoInfoList = GetBingoIndexList(cellIndex, v, cardId, v.num)
            if #newBingoInfoList > 0 then
                fun.merge_array(totalBingoInfoList, newBingoInfoList)
            end
            local jackpot = this.CalculateJackpot(cardId, cellIndex, v)
            if jackpot ~= nil then
                local bingoInfo = {
                    type = this.BingoType.JACKPOT,
                    numbers = jackpot,
                    cardId = cardId,
                    totolCount = self.totalBingoCount[cardId], 
                    th = 0
                }
                table.insert(totalBingoInfoList, bingoInfo)
            end
            --CheckCalculateSkillMakeBingo(cellIndex,v,cardId)
            this:CalculateCardWish(cardId, v)
        end
    end

    if #totalBingoInfoList > 0 then
        if #totalBingoInfoList > 1 then
            for i = 1, #totalBingoInfoList do
                Event.Brocast(EventName.Player_Bingo_Reduce_Bingoleft, {totalBingoInfoList[i]}, cardId)
                Event.Brocast(EventName.Player_Bingo_Count_Be_Change, {totalBingoInfoList[i]})
            end
        else
            Event.Brocast(EventName.Player_Bingo_Reduce_Bingoleft, totalBingoInfoList, cardId)
            Event.Brocast(EventName.Player_Bingo_Count_Be_Change, totalBingoInfoList)
        end
    end
end

--- 计算是否出现bingo  盖章使用
---@param index
function GoldenTrainBingoRule.OnInitCalcuateWish(cardId)
    this.data = ModelList.BattleModel:GetCurrModel():GetRoundData()
    for k, v in pairs(this.data) do
        local cardId = tostring(cardId)
        if k == cardId then
            this:CalculateCardWish(cardId,v)
        end
    end
end

--- 计算是否出现wish,
function GoldenTrainBingoRule:CalculateWishByCard(cardId)
    local curModel = ModelList.BattleModel:GetCurrModel()
    if curModel and not curModel:CanShowSkillCellWish() then
        return
    end
    
    for k, v in pairs(this.data) do
        local caidid = tostring(cardId)
        if k == caidid then
            this:CalculateCardWish(cardId,v)
        end
    end
end

--- 计算是否出现wish,
function GoldenTrainBingoRule:CalculateCardWish(cardId,cardInfo)
    local curModel = ModelList.BattleModel:GetCurrModel()
    if curModel and not curModel:CanShowSkillCellWish() then
        return
    end
    
    local wishList, cancelWishList = GetCardMakeBingoSkillCellList(cardInfo,cardId)
    if #wishList > 0 then
        for i = 1, #wishList do
            CheckCalculateSkillMakeBingo(wishList[i],cardInfo,cardId)
        end
    end
    if #cancelWishList > 0 then
        for i = 1, #cancelWishList do
            CalculateCancelSkillMakeBingo(cancelWishList[i],cardInfo,cardId)
        end
    end
end

function GoldenTrainBingoRule.CalculateJackpot(cardId, cellIndex,cardInfo)
    if this.jackpotRule then
        if fun.is_include(cellIndex, this.jackpotRule) then
            for k, v in pairs(this.data) do
                local caidid = tostring(cardId)
                if k == caidid then
                    local allHasSign = true
                    local lessAchievedJackpotCount  = 0
                    oneLessAchievedJackpotList = {}
                    for n = 1, #this.jackpotRule do
                        local cell_index = this.jackpotRule[n]
                        if v.cards[cell_index].sign == 0 and cell_index ~= cellIndex then
                            allHasSign = false
                            lessAchievedJackpotCount = lessAchievedJackpotCount + 1
                            table.insert(oneLessAchievedJackpotList,cell_index)
                        elseif v.cards[cell_index].forbiddenSignType then
                            allHasSign = false
                        end
                    end
                    if allHasSign then
                        local newBingoInfoList = deep_copy(this.jackpotRule)
                        return newBingoInfoList
                    else
                        local curModel = ModelList.BattleModel:GetCurrModel()
                        if curModel and curModel:CanShowNormalCellJackpotWish() then
                            ---差n个就形成了Jackpot
                            local needCount = curModel:GetLessAchievedJackpotNeedCount()
                            if lessAchievedJackpotCount <= needCount then
                                table.each(oneLessAchievedJackpotList, function(cellI)
                                    if cardInfo.cards[cellI].wishState == 0 then
                                        OnelessAchievedBingoEffect(cardId, cellI)
                                        cardInfo.cards[cellI].wishState = 1
                                    end
                                end)
                            end
                        end
                    end
                end
            end
        end
    end
    
    return nil
end

--- 获取计算bingo可以忽略的坐标格子
function GoldenTrainBingoRule: GetIgnorePos(skillId, cellIndex, ignoreList, cardData,cardId)
    local skill_type = Csv.GetData("skill", skillId, "skill_type")
    cardId = tostring(cardId)
    if skill_type == 1 then return end
    if skill_type == 7 then return end
    if skill_type == 8 then return end
    local skillXYZ = Csv.GetData("skill", skillId, "skill_xyz")
    local ori_x = math.modf((cellIndex - 1) / 5)
    local ori_y = math.modf((cellIndex - 1) % 5)
    for i = 1, #skillXYZ do
        local new_x = ori_x + skillXYZ[i][1]
        local new_y = ori_y - skillXYZ[i][2]
        if new_x >= 0 and new_x <= 4 and new_y >= 0 and new_y <= 4 then
            local new_index = new_x * 5 + new_y + 1
            for k, v in pairs(this.data) do
                if k == cardId and v.cards[new_index].sign == 0 then
                    table.insert(ignoreList, new_index)
                    break
                end
            end
            if #cardData.cards[new_index].skill_id > 0 and cardData.cards[new_index].sign == 0 and  not fun.is_include(new_index,ignoreList) then
                for m = 1, #cardData.cards[new_index].skill_id do
                    this:GetIgnorePos(cardData.cards[new_index].skill_id[m], new_index, ignoreList, cardData,cardId)
                end
            end
        end
    end
end

function GoldenTrainBingoRule:PreCalSkillBingo(skillId, cellIndex, cardInfo)
    local ignoreList = {}
    for i = 1, #skillId do
        this:GetIgnorePos(skillId[i], cellIndex, ignoreList, cardInfo)
    end
    return CalBingoWithIgnoreList(cellIndex, cardInfo, ignoreList)
end

function GoldenTrainBingoRule:GetSkillIgnoreCellList(skillId, cellIndex, cardInfo,cardId)
    local ignoreList = {}
    for i = 1, #skillId do
        this:GetIgnorePos(skillId[i], cellIndex, ignoreList, cardInfo,cardId)
    end
    return ignoreList
end

--- 兴奋叫号_叫号时候提前检查卡牌内可形成bingo列表的格子ID
local PreCheckCanGetBingo = function(cellIndex, cardInfo, cardId, skillId)
    if cardInfo.cards[cellIndex].sign > 0 then
        return false
    end
    --检查bingo格
    if PreGetBingoCellIndexList(cellIndex, cardInfo, cardId) then
        return true
    end
    local ignoreList = this:GetSkillIgnoreCellList(skillId,cellIndex,cardInfo,cardId)
    --检查普通bingo
    local normalBingo = CalBingoWithIgnoreList(cellIndex,cardInfo,ignoreList)
    if normalBingo then  return true   end

    --检查技能的其他格子
    if skillId and #skillId > 0 and #ignoreList >0 then
        for i = 1, #ignoreList do
            local otherSkillBingo = CalBingoWithIgnoreList(ignoreList[i],cardInfo,ignoreList)
            if otherSkillBingo then

                return true
            end
        end
    end
    return false
end

---  提前计算_叫号是否能形成bingo_叫号机使用
function GoldenTrainBingoRule:PreCalculateBingo(num)
    for k, v in pairs(this.data) do
        for j = 1, #v.cards do
            if v.cards[j].num == num and v.cards[j].sign == 0 then
                if PreCheckCanGetBingo(j, v, k, v.cards[j].skill_id) then
                    return true
                end
                break
            end
        end
    end
    return false
end

function GoldenTrainBingoRule:BeBingoCell(cardId,cellIndex,cardNum)
    local newCell = {cardId =cardId,index = cellIndex, num =cardNum}
    table.insert(this.bingoCell, newCell)
end

function GoldenTrainBingoRule:OnDataChange(cardId, cellIndex, ...)
    local arg = { ... }
    for k, v in pairs(this.data) do
        local caidid = tostring(cardId)
        if k == caidid then
            v.cards[cellIndex].forbiddenSignType = false
        end
    end
end

return this
