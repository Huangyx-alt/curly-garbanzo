---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2022/2/9 15:05
---
local CardCoinEffect = Clazz(ClazzBase, "CardCoinEffect")

local this = CardCoinEffect

this.coinsPool = {}

function CardCoinEffect:SetCardView(cardView)
    this.cardView = cardView
    this.coinFlyTime = {}
end

function CardCoinEffect:GetCoinObj(isCompetition,i,pointCount)
    if isCompetition and i >= pointCount - 3 then
        return GoPool.pop("competitionBingoCoin")
    else
        return GoPool.pop("normal_bingo_coin")
    end
end

--播金币+奖杯
function CardCoinEffect:GetIconObj(isCompetition, i, pointCount)
    if isCompetition and i >= pointCount - 3 then
        return GoPool.pop("competitionBingoCoin")
    elseif i <= pointCount / 2 then
        return GoPool.pop("normal_bingo_coin")
    else
        return GoPool.pop("normal_bingo_zbcup")
    end
end

local calc_distance = function(point1, point2)
    local x = point1.x - point2.x
    local y = point1.y - point2.y
    return math.sqrt(x * x + y * y)
end

function CardCoinEffect:InitFlyCoins(mapIndex, pos, box, showOtherIcon)
    this.coinsPool = this.cardView.coinsPool
    if this.coinsPool == nil then
        this.coinsPool = {}
        this.coinsPool[mapIndex] = {}
    end
    this.coinsPool[mapIndex] = this.coinsPool[mapIndex] or {}
    local lastCoinsCount = GetTableLength(this.coinsPool[mapIndex])
    
    --初始化指定数量的icon对象
    local pointCount, validCount = 10, 0 --要生成点的数量, 实际创建的数量
    UISound.play_loop("chips")
    local gameType = ModelList.BattleModel:GetGameCityPlayID()
    local bingo_coin_sibling = Csv.GetData("new_game_effect_cache",gameType,"bingo_coin_sibling")
    local isCompetition = ModelList.BattleModel:IsCompetition()
    for i = 1, pointCount do
        local obj
        if showOtherIcon then
            obj = self:GetIconObj(isCompetition,i,pointCount)
        else
            obj = self:GetCoinObj(isCompetition,i,pointCount)
        end
        if fun.is_not_null(obj) then
            table.insert(this.coinsPool[mapIndex], obj)
            if bingo_coin_sibling == 2 then fun.SetAsFirstSibling(obj)
            elseif bingo_coin_sibling == 1 then fun.SetAsLastSibling(obj) end
            validCount = validCount + 1
        end
    end
    --未生成对象，return
    if validCount == 0 then
        return
    end
    pointCount = validCount
    
    -- 计算矩形范围8个随机方向散列移动位置
    local coinIndex = lastCoinsCount - pointCount + 1 >0 and lastCoinsCount - pointCount + 1 or 1
    local first_coin = this.coinsPool[mapIndex][coinIndex]
    local resultList = {}
    local rectX = 300-- //要生成点半径
    local rectY = 300-- //要生成点半径
    local ranX;
    local ranY;
    local tempCount = 0
    while (tempCount < pointCount) do
        ranX = math.random(-rectX, rectX)
        ranY = math.random(-rectY, rectY)
        tempCount = tempCount + 1
        table.insert(resultList, { x = ranX, y = ranY, z = 0 })
    end
    --所有点排序
    local tarPos = fun.get_gameobject_pos(box, true)
    table.sort(resultList, function(a, b)
        return calc_distance(a, tarPos) < calc_distance(b, tarPos)
    end)
    
    --散列移动
    local start_index = #this.coinsPool[mapIndex] - pointCount
    for i = 1, pointCount do
        local trans = this.coinsPool[mapIndex][i + start_index]
        if trans then
            fun.set_transform_pos(trans.transform, pos.x, pos.y, pos.z, false)
            local local_pos = fun.get_gameobject_pos(trans, true)
            local v_new = local_pos + resultList[i]
            fun.set_active(trans, true, 0)
            Anim.move_to_xy_local(trans.gameObject, v_new.x, v_new.y, 0.1)
        end
    end
    
    --播特效
    BattleEffectCache:GetSkillPrefabFromCache("cityget",this.coinsPool[mapIndex][start_index+1], nil,2)
    UISound.play("coinup_fast")
    this.cardView:ShowBox()
    
    --逐个飞向右上角箱子
    local bingoCount = CalculateBingoMachine.GetTotalBingoCount(tonumber(mapIndex))
    local time_index = mapIndex .. start_index
    if bingoCount  then
        time_index = mapIndex .. start_index .. bingoCount
    end
    this.coinFlyTime[time_index] = LuaTimer:SetDelayFunction(0.8, function()
        local delay = 0
        local new_start_index = 1
        if this.coinsPool ~= nil and this.coinsPool[mapIndex] ~= nil then
            for i = 1, #this.coinsPool[mapIndex] do
                if this.coinsPool[mapIndex][i] == first_coin then
                    new_start_index = i
                    break
                end
            end
            for i = 0, pointCount -1 do
                local v_new = Vector3.New(394, 673, 0)
                local curr_index = new_start_index + i
                this:FlyToBox(this.coinsPool[mapIndex][curr_index], v_new, delay, mapIndex,curr_index)
                delay = delay + 0.03
            end
        end
        if this.coinFlyTime[time_index] then
            LuaTimer:Remove(this.coinFlyTime[time_index])
        end
    end)
end

function CardCoinEffect:FlyToBox(obj, to, delay, mapIndex,coinIndex)
    if fun.is_not_null(obj) then
        LuaTimer:SetDelayFunction(delay,function()
            if fun.is_not_null(obj) then
                Anim.scale_to_xy(obj,0.6,0.6,0.5,nil)
            end
        end)
        Anim.delay_move(obj, to, 0.5, delay, true, function()
            if coinIndex == 1 then
                local ob = BattleEffectPool:Get("boxjinbibao",obj)
                BattleEffectPool:DelayRecycle("boxjinbibao",ob,2)
            end
            this:HideCoin(mapIndex,obj)
        end)
    else
        this:HideCoin(mapIndex)
    end
end


function CardCoinEffect:HideCoin(mapIndex,resObj)
    if 0 < #this.coinsPool[mapIndex] then
        local obj = this.coinsPool[mapIndex][1]
        --- 直取Obj，如果是第一个，就遍历一次找到对应的
        if obj ~= resObj then
            local find, key  = table.find(this.coinsPool[mapIndex], function(k, v)
                return v == resObj
            end)
            if find then
                obj = table.remove(this.coinsPool[mapIndex], key)
            else
                obj = table.remove(this.coinsPool[mapIndex], 1)
            end
        else
            obj = table.remove(this.coinsPool[mapIndex], 1)
        end
        fun.set_active(obj, false)
        --- 必须要加延迟回收，小概率会出现回收后的金币又给了同一张卡，假如前后都是作为firstCoin,会导致金币池顺序错乱。
        if fun.starts(obj.name,"Competition") then
            BattleEffectPool:DelayRecycle("competitionBingoCoin", obj,0.5)
        elseif fun.starts(obj.name,"ef_Bingo_ZB") then
            BattleEffectPool:DelayRecycle("normal_bingo_zbcup", obj,0.5)
        else
            BattleEffectPool:DelayRecycle("normal_bingo_coin", obj,0.5)
        end
        Event.Brocast(EventName.Box_Trigger_Hit)
        if #this.coinsPool[mapIndex] == 0 then
            this:HideBox()
        end
    end
end

function CardCoinEffect:HideBox(box_type)
    Event.Brocast(EventName.FlyItem_HideBoxFun,box_type,this.coinsPool)
end

function CardCoinEffect:OnDisable()
    for k, v in pairs(this.coinFlyTime) do
        LuaTimer:Remove(v)
    end
end

function CardCoinEffect:HasCoinCountInPool()
    for k, v in pairs(this.coinsPool) do
        if v and #v > 0 then
            return true
        end
    end
    return false
end

--- 清理this.coinsPool
function CardCoinEffect:ClearCoinPool()
    this.coinsPool = {}
end

return this
