---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PC.
--- DateTime: 2022/2/25 14:13
---
--- bingoleft 减号机

require("Combat/BaseMachine")
require("Combat/Machine/BingoOrderMachine")
BingoLeftTickMachine = BaseMachine:New("BingoLeftTickMachine")

local this = BingoLeftTickMachine
this.bingoleftTick = nil
this.startPlayingTime = 0
this.gamePlayingTime = 0
this.bingoLeftCount = 0   --bingoleft个数
this.callCd = 1
this.timeScale = 1
this.acceleration = 1  --追赶正常进度的加速度
this.trigger_last_20_time = false
this.trigger_last_1_time = false

--- 模拟发送消息,每个战斗Model接收bingo变化
local DispatchBingoleftMessage = function(bingoleftData, isRobotTrigger)
    local options = bingoleftData and bingoleftData.options or {}
    if ModelList.BattleModel:GetCurrModel() ~= nil then
        if isRobotTrigger then
            CmdRobotTriggerBingo:OnCmdExecute({ bingoleftData = bingoleftData })
        else
            if options.onlyCheckSelfBingoCell then
                CmdTriggerSelfBingoSkill:OnCmdExecute({ bingoleftData = bingoleftData })
            else
                CmdTriggerBingo:OnCmdExecute({ bingoleftData = bingoleftData })
            end
        end
        return true
    else
        fun.SafeCall(options.onBingoShowComplete)
        return false
    end
end

local InitTickData = function(loadData)
    local bingoTicks = loadData.bingoLeftTick
    this.bingoleftTick = {}
    
    local gameType = ModelList.BattleModel:GetGameType()
    --WinZone玩法需要合并bingoLeftTick和jackpotLeftTick
    if gameType == PLAY_TYPE.PLAY_TYPE_VICTORY_BEATS then
        local jackpotTicks = loadData.jackpotLeftTick
        bingoTicks = fun.merge_array(bingoTicks, jackpotTicks)
        --bingoTicks = fun.table_unique(bingoTicks)
        bingoTicks = table.values(bingoTicks)
        table.sort(bingoTicks)
        
        --可能一个tick对应多个bingo
        loadData.bingoLeft = #bingoTicks
    end

    for i = 1, #bingoTicks do
        this.bingoleftTick[i] = bingoTicks[i] * 0.01
    end
end

function BingoLeftTickMachine:Start(loadData)
    InitTickData(loadData)
    local bingoLeft = loadData.bingoLeft
    this.update_x_enabled = true
    this.gamePlayingTime = 0
    this.bingoLeftCount = bingoLeft
    this.callCd = loadData.callCd
    this.timeScale = 1
    this.acceleration = 1
    this.trigger_last_20_time = false
    this.trigger_last_1_time = false
    this.gameType = ModelList.BattleModel:GetGameType()
    this:start_x_update()
end

function BingoLeftTickMachine:Pause(isPause)
    this.isPause = isPause
    this.update_x_enabled = (not isPause)
end

function BingoLeftTickMachine:on_x_update()
    if this.update_x_enabled then
        this.gamePlayingTime = this.gamePlayingTime + UnityEngine.Time.deltaTime * this.timeScale*this.acceleration
        this.removeList = {}
        local next = 0

        for i = 1, #this.bingoleftTick do
            if this.gamePlayingTime > this.bingoleftTick[i] then
                table.insert(this.removeList, this.bingoleftTick[i])
            else
                if i - 1 > 0 then
                    next = this.bingoleftTick[i] - this.bingoleftTick[i - 1]
                else
                    next = this.bingoleftTick[i] - this.gamePlayingTime
                end
                break
            end
        end
        if #this.removeList > 0 then
            this.bingoleftData = { gameId = 0, bingoLeft = 0, bingoChange = 0, cardId = 0, next = 0, bingoId = 0, robots = {} }
            local count = #this.removeList
            this.bingoLeftCount = this.bingoLeftCount - count
            this.bingoleftData.bingoLeft = this.bingoLeftCount
            this.bingoleftData.bingoChange = count
            this.bingoleftData.next = next
            this.bingoleftData.bingo = {}
            this.bingoleftData.ticks = this.removeList --触发bingo的tick
            for i = 1, count do
                table.insert(this.bingoleftData.robots, BingoOrderMachine:GetRobot())
            end
            if DispatchBingoleftMessage(this.bingoleftData, true) then
                Event.Brocast(EventName.Refresh_Robot_Bingo_Order, this.bingoleftData.robots)
                for i = 1, count do
                    table.remove(this.bingoleftTick, 1)
                end
            else
				BingoLeftTickMachine:Stop()
                return
            end
            --log.e ("logtick bingoLeftCount  "..this.bingoLeftCount.."     gamePlayingTime "..this.gamePlayingTime)
        end
        this:CheckLeftTime()
    end
end

function BingoLeftTickMachine:Stop()
    this.update_x_enabled = false
    this:stop_x_update()
end

function BingoLeftTickMachine.ReduceBingoleftTick(owner, bingoData, cardId, options)
    local next = 0
    local bingoleftData = { gameId = 0, bingoLeft = 0, bingoChange = 0, cardId = cardId, next = 0, bingoId = 0, robots = {}, bingo = bingoData }
    local count, ticks = #bingoData, {}
    for i = 1, count do
        if #this.bingoleftTick > 0 then
            table.remove(this.bingoleftTick, 1)
            --log.e("玩家bingo -1")
            if #this.bingoleftTick > 0 then
                if i - 1 > 0 and #this.bingoleftTick > 1 and this.bingoleftTick[i]  then
                    log.b("玩家bingo   "..this.bingoleftTick[i].."   "..#this.bingoleftTick)
                    next = this.bingoleftTick[i] - this.bingoleftTick[i - 1]
                elseif i<= #this.bingoleftTick then
                    next = this.bingoleftTick[i] - this.gamePlayingTime
                else
                    next = 0
                end
            end
        else
            log.e(" there are no enough bingolefttick  " .. i .. "   " .. count)
        end
    end
    this.bingoLeftCount = this.bingoLeftCount - count
    bingoleftData.bingoLeft = this.bingoLeftCount
    bingoleftData.bingoChange = count
    bingoleftData.next = next
    bingoleftData.ticks = ticks
    bingoleftData.options = options or {}
    if DispatchBingoleftMessage(bingoleftData) then
        this.CheckStopCallNumber()
    end
    log.r("logtick ReduceBingoleftTick bingoLeftCount = "..this.bingoLeftCount)
end

function BingoLeftTickMachine.CheckStopCallNumber()
    if this.bingoLeftCount <= 0 and BattleMachineList.GetMchine("CallNumberMachine")  then
        BattleMachineList.GetMchine("CallNumberMachine"):Stop()
    end
end

function BingoLeftTickMachine:ChangeCallNumberCD(callcd)
    this.timeScale = this.callCd / callcd
    log.g(" timeScale  " .. this.timeScale)
end

function BingoLeftTickMachine.AccelerateProgress(owner, acceleration)
    this.acceleration = acceleration
end

function BingoLeftTickMachine.Register()
    Event.AddListener(EventName.Player_Bingo_Reduce_Bingoleft, this.ReduceBingoleftTick)
    Event.AddListener(EventName.Change_Call_Number_CD, this.ChangeCallNumberCD,this)
    Event.AddListener(EventName.Accelerate_Progress_With_Bingoleft_Tick, this.AccelerateProgress)
end

function BingoLeftTickMachine.UnRegister()
    Event.RemoveListener(EventName.Player_Bingo_Reduce_Bingoleft, this.ReduceBingoleftTick)
    Event.RemoveListener(EventName.Change_Call_Number_CD, this.ChangeCallNumberCD,this)
    Event.RemoveListener(EventName.Accelerate_Progress_With_Bingoleft_Tick, this.AccelerateProgress)
end


function BingoLeftTickMachine:CheckLeftTime()
    if #this.bingoleftTick>0 then
        local last = this.bingoleftTick[ #this.bingoleftTick ]
        --战斗最后20S钟，人喧闹声逐渐变大
        if last - this.gamePlayingTime <20 and  not this.trigger_last_20_time  then
            this.trigger_last_20_time = true
            UISound.tween_out_music("whisper.mp3", 2, 0.7, 1, nil)
        end

        --最后1S，摇铃提示
        if not this.trigger_last_1_time   and  last - this.gamePlayingTime <=1 then
            this.trigger_last_1_time = true
            --UISound.play()
        end
    end
end


return this